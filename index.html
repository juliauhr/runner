<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HEAD RUN ‚Äî VR Infinite Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.2/aframe.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; font-family: 'Courier New', monospace; overflow: hidden; }

    #ui-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      z-index: 100; display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,0.88); color: #00ffcc; pointer-events: none;
    }
    #ui-overlay.hidden { display: none; }
    #start-screen { text-align: center; pointer-events: all; }
    #start-screen h1 {
      font-size: clamp(2rem, 6vw, 4rem); letter-spacing: 0.3em;
      color: #00ffcc; text-shadow: 0 0 30px #00ffcc, 0 0 60px #00ffcc88;
      margin-bottom: 0.4rem;
    }
    .subtitle { font-size: 0.9rem; letter-spacing: 0.2em; color: #00ffcc66; margin-bottom: 2.5rem; }
    .instruction {
      background: rgba(0,255,204,0.05); border: 1px solid rgba(0,255,204,0.25);
      border-radius: 8px; padding: 1rem 1.5rem; margin-bottom: 0.8rem;
      max-width: 380px; text-align: left; font-size: 0.82rem; line-height: 1.7; color: #aaffee;
    }
    .instruction strong {
      color: #00ffcc; display: block; margin-bottom: 0.3rem;
      font-size: 0.7rem; letter-spacing: 0.15em; text-transform: uppercase;
    }
    button {
      margin-top: 1.5rem; padding: 0.9rem 2.5rem;
      background: transparent; border: 2px solid #00ffcc;
      color: #00ffcc; font-family: 'Courier New', monospace;
      font-size: 0.95rem; letter-spacing: 0.3em; text-transform: uppercase;
      cursor: pointer; transition: all 0.2s; box-shadow: 0 0 20px rgba(0,255,204,0.15);
    }
    button:hover { background: rgba(0,255,204,0.1); }

    #hud {
      position: fixed; top: 0; left: 0; right: 0; z-index: 50;
      padding: 1rem 1.5rem; display: flex; justify-content: space-between; pointer-events: none;
    }
    #hud.hidden { display: none; }
    .hud-panel {
      background: rgba(0,0,0,0.6); border: 1px solid rgba(0,255,204,0.3);
      border-radius: 6px; padding: 0.4rem 0.9rem; color: #00ffcc;
    }
    .hud-label { font-size: 0.55rem; letter-spacing: 0.2em; text-transform: uppercase; color: #00ffcc55; }
    .hud-value { font-size: 1.3rem; letter-spacing: 0.1em; text-shadow: 0 0 8px #00ffcc; }

    #bob-meter {
      position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%);
      z-index: 50; width: 180px; pointer-events: none;
    }
    #bob-meter.hidden { display: none; }
    .meter-label { text-align: center; font-size: 0.58rem; letter-spacing: 0.15em; text-transform: uppercase; color: #00ffcc55; margin-bottom: 4px; }
    .meter-bg { background: rgba(0,255,204,0.1); border: 1px solid rgba(0,255,204,0.3); border-radius: 20px; height: 8px; overflow: hidden; }
    #meter-fill { height: 100%; background: linear-gradient(90deg, #00ffcc, #00ff88); border-radius: 20px; width: 0%; box-shadow: 0 0 8px #00ffcc; transition: width 0.08s; }

    #game-over-screen { text-align: center; pointer-events: all; display: none; }
    #game-over-screen.visible { display: block; }
    #game-over-screen h2 { font-size: clamp(1.5rem, 5vw, 3rem); letter-spacing: 0.3em; color: #ff4466; text-shadow: 0 0 30px #ff4466; margin-bottom: 1rem; }
    #final-score { font-size: 1.1rem; color: #00ffcc; margin-bottom: 1.5rem; letter-spacing: 0.15em; }
  </style>
</head>
<body>

<div id="ui-overlay">
  <div id="start-screen">
    <h1>HEAD RUN</h1>
    <p class="subtitle">‚àû infinite vr runner ‚àû</p>
    <div class="instruction">
      <strong>üéÆ How to Move</strong>
      Bob your head up and down rhythmically ‚Äî each full bob cycle propels you forward. Stop and you stop.
    </div>
    <div class="instruction">
      <strong>‚ö†Ô∏è Dodge Obstacles</strong>
      Look left or right to steer. Speed increases with distance.
    </div>
    <div class="instruction">
      <strong>üíª No Headset?</strong>
      Tap <kbd>W</kbd> rhythmically to simulate steps. <kbd>A</kbd>/<kbd>D</kbd> or mouse to steer.
    </div>
    <button onclick="startGame()">ENTER THE RUN</button>
  </div>
  <div id="game-over-screen">
    <h2>COLLISION</h2>
    <div id="final-score">DISTANCE: 0m</div>
    <button onclick="restartGame()">RUN AGAIN</button>
  </div>
</div>

<div id="hud" class="hidden">
  <div class="hud-panel">
    <div class="hud-label">Distance</div>
    <div class="hud-value" id="score-display">0m</div>
  </div>
  <div class="hud-panel">
    <div class="hud-label">Speed</div>
    <div class="hud-value" id="speed-display">‚Äî</div>
  </div>
</div>

<div id="bob-meter" class="hidden">
  <div class="meter-label">Bob Meter</div>
  <div class="meter-bg"><div id="meter-fill"></div></div>
</div>

<a-scene id="scene"
  background="color: #050510"
  fog="type: exponential; color: #050510; density: 0.035"
  vr-mode-ui="enabled: true"
  renderer="antialias: true; colorManagement: true">

  <a-entity id="rig" position="0 0 0">
    <a-camera id="head-cam"
      position="0 1.6 0"
      look-controls="pointerLockEnabled: false"
      wasd-controls="enabled: false">

      <!-- Reticle -->
      <a-entity position="0 0 -3"
        geometry="primitive: ring; radiusInner: 0.012; radiusOuter: 0.022"
        material="color: #00ffcc; opacity: 0.6; shader: flat">
      </a-entity>

      <!-- In-VR debug HUD: bottom-left of view, always visible -->
      <a-entity position="-0.38 -0.28 -0.7">
        <a-plane width="0.55" height="0.24"
          material="color: #000010; opacity: 0.8; shader: flat; transparent: true">
        </a-plane>
        <a-text id="vr-debug-text"
          value="Waiting..."
          color="#00ffcc" width="0.9" align="left" anchor="left"
          position="-0.26 0.08 0.005" wrap-count="32" font="mozillavr">
        </a-text>
        <a-text id="vr-step-text" value=""
          color="#ffffff" width="1.1" align="center"
          position="0 -0.08 0.005" font="mozillavr">
        </a-text>
      </a-entity>
    </a-camera>
  </a-entity>

  <a-entity id="track-container"></a-entity>

  <a-light type="ambient" color="#001122" intensity="0.5"></a-light>
  <a-light type="directional" color="#00ffcc" intensity="0.3" position="0 5 -5"></a-light>

</a-scene>

<script>
// ============================================================
//  CONSTANTS
// ============================================================
const SEG_LEN   = 10;
const SEG_COUNT = 14;
const TW        = 6;      // track width
const TH        = 3.5;    // track height
const LANE_W    = 1.5;

// Bob detection tuning
const BOB_EXCURSION  = 0.018; // metres peak-to-valley needed for a step (~1.8cm)
const BOB_ALPHA      = 0.3;   // EMA smoothing (lower = smoother but more lag)
const DIR_CONFIRM    = 4;     // frames needed to confirm a direction change
const BOB_COOLDOWN_S = 0.22;  // min seconds between registered steps

// Movement
const BOOST_PER_STEP = 14;    // speed units added per step
const BOOST_DECAY    = 7;     // speed units lost per second

// ============================================================
//  GAME STATE
// ============================================================
let gameActive = false;
let gameOver   = false;

let trackZ    = 0;
let playerX   = 0;
let distance  = 0;
let stepBoost = 0;
let speedCap  = 14;

let segments  = [];
let obstacles = [];

// Bob detector
let smoothY    = null;
let prevSmooth = null;
let peakY      = null;
let valleyY    = null;
let bobDir     = 0;    // confirmed direction: 1=up, -1=down, 0=unknown
let dirCount   = 0;    // running confirmation counter
let bobCooldown = 0;
let totalSteps = 0;

// Keyboard
let keys   = {};
let kbTimer = 0;

// Loop
let lastTime = null;

// ============================================================
//  INIT
// ============================================================
window.addEventListener('DOMContentLoaded', () => {
  document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
  document.addEventListener('keyup',   e => keys[e.key.toLowerCase()] = false);
  document.getElementById('scene').addEventListener('loaded', buildTrack);
});

function buildTrack() {
  for (let i = 0; i < SEG_COUNT; i++) spawnSegment(i * SEG_LEN);
}

// ============================================================
//  TRACK GENERATION
// ============================================================
function spawnSegment(z) {
  const el = document.createElement('a-entity');
  el.setAttribute('position', `0 0 -${z}`);

  makePlane(el, 0,     0,      -SEG_LEN/2, TW,     SEG_LEN, '-90 0 0', '#001133', '#000511');
  makePlane(el, -TW/2, TH/2,   -SEG_LEN/2, SEG_LEN, TH, '0 90 0',  '#000a22', '#001133');
  makePlane(el,  TW/2, TH/2,   -SEG_LEN/2, SEG_LEN, TH, '0 -90 0', '#000a22', '#001133');
  makePlane(el, 0,     TH,     -SEG_LEN/2, TW,     SEG_LEN, '90 0 0',  '#000822', '#000a1a');

  makeStrip(el, -TW/2+0.05, 0.05,    '#00ffcc');
  makeStrip(el,  TW/2-0.05, 0.05,    '#00ffcc');
  makeStrip(el, -TW/2+0.05, TH-0.05, '#0066ff');
  makeStrip(el,  TW/2-0.05, TH-0.05, '#0066ff');

  if (z > 30 && Math.random() < 0.7) spawnObstacle(el, z);

  document.getElementById('track-container').appendChild(el);
  segments.push({ el, z });
}

function makePlane(p, x, y, z, w, h, rot, color, emissive) {
  const el = document.createElement('a-plane');
  el.setAttribute('position', `${x} ${y} ${z}`);
  el.setAttribute('rotation', rot);
  el.setAttribute('width', w);
  el.setAttribute('height', h);
  el.setAttribute('material', `color:${color};emissive:${emissive};emissiveIntensity:0.4;roughness:0.7`);
  p.appendChild(el);
}

function makeStrip(p, x, y, color) {
  const el = document.createElement('a-box');
  el.setAttribute('position', `${x} ${y} -${SEG_LEN/2}`);
  el.setAttribute('width', 0.05); el.setAttribute('height', 0.05); el.setAttribute('depth', SEG_LEN);
  el.setAttribute('material', `color:${color};emissive:${color};emissiveIntensity:1;shader:flat`);
  p.appendChild(el);
}

function spawnObstacle(parent, segZ) {
  const type = Math.floor(Math.random() * 4);
  const lz = -(SEG_LEN * 0.25 + Math.random() * SEG_LEN * 0.5);

  if (type === 0) {
    const right = Math.random() < 0.5;
    makeObstacle(parent, segZ, right ? TW/4 : -TW/4, TH/2, lz, TW/2-0.9, TH, 0.5, '#ff2244', '#ff4466');
  } else if (type === 1) {
    const lx = (Math.floor(Math.random() * 3) - 1) * LANE_W;
    makeObstacle(parent, segZ, lx, TH/2, lz, 1.1, TH, 1.1, '#ff6600', '#ff8800');
  } else if (type === 2) {
    makeObstacle(parent, segZ, 0, 0.5, lz, TW-0.5, 0.6, 0.5, '#aa00ff', '#cc44ff');
  } else {
    makeObstacle(parent, segZ, 0, TH-0.5, lz, TW-0.5, 0.6, 0.5, '#0088ff', '#44aaff');
  }
}

function makeObstacle(parent, segZ, x, y, lz, w, h, d, color, emissive) {
  const el = document.createElement('a-box');
  el.setAttribute('position', `${x} ${y} ${lz}`);
  el.setAttribute('width', w); el.setAttribute('height', h); el.setAttribute('depth', d);
  el.setAttribute('material', `color:${color};emissive:${emissive};emissiveIntensity:0.85;transparent:true;opacity:0.92`);
  parent.appendChild(el);
  obstacles.push({ parent, segZ, lz, x, y, hw: w/2, hh: h/2 });
}

// ============================================================
//  GAME CONTROL
// ============================================================
function startGame() {
  document.getElementById('ui-overlay').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  document.getElementById('bob-meter').classList.remove('hidden');
  document.getElementById('start-screen').style.display = 'block';

  gameActive = true; gameOver = false;
  trackZ = 0; playerX = 0; distance = 0;
  stepBoost = 0; speedCap = 14;
  totalSteps = 0; lastTime = null; kbTimer = 0;

  // Reset bob state
  smoothY = null; prevSmooth = null;
  peakY = null; valleyY = null;
  bobDir = 0; dirCount = 0; bobCooldown = 0;

  const container = document.getElementById('track-container');
  while (container.firstChild) container.removeChild(container.firstChild);
  segments = []; obstacles = [];
  buildTrack();

  document.getElementById('rig').setAttribute('position', '0 0 0');
  requestAnimationFrame(gameLoop);
}

function restartGame() {
  document.getElementById('game-over-screen').classList.remove('visible');
  startGame();
}

function endGame() {
  if (gameOver) return;
  gameOver = true; gameActive = false;
  document.getElementById('hud').classList.add('hidden');
  document.getElementById('bob-meter').classList.add('hidden');
  document.getElementById('final-score').textContent = 'DISTANCE: ' + Math.floor(distance) + 'm';
  document.getElementById('ui-overlay').classList.remove('hidden');
  document.getElementById('game-over-screen').classList.add('visible');
  document.getElementById('start-screen').style.display = 'none';
}

// ============================================================
//  MAIN LOOP
// ============================================================
function gameLoop(ts) {
  if (!gameActive) return;
  if (!lastTime) lastTime = ts;
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;

  // Head bob from camera world position
  const cam = document.getElementById('head-cam');
  if (cam && cam.object3D) {
    const wp = new THREE.Vector3();
    cam.object3D.getWorldPosition(wp);
    detectBob(wp.y, dt);
  }

  // Keyboard steps
  handleKeys(dt);

  // Cooldown tick
  if (bobCooldown > 0) bobCooldown -= dt;

  // Steering
  let steer = 0;
  if (keys['a'] || keys['arrowleft'])  steer = -1;
  if (keys['d'] || keys['arrowright']) steer =  1;
  if (steer === 0 && cam && cam.object3D) {
    const dir = new THREE.Vector3();
    cam.object3D.getWorldDirection(dir);
    steer = Math.max(-1, Math.min(1, dir.x * 2.2));
  }
  playerX = Math.max(-TW/2+0.6, Math.min(TW/2-0.6, playerX + steer * 4 * dt));
  document.getElementById('rig').setAttribute('position', `${playerX} 0 0`);

  // Forward movement ‚Äî bob-driven only
  trackZ   += stepBoost * dt;
  distance += stepBoost * dt;
  stepBoost = Math.max(0, stepBoost - BOOST_DECAY * dt);
  speedCap  = Math.min(30, 14 + distance * 0.006);

  document.getElementById('track-container').setAttribute('position', `0 0 ${trackZ}`);

  // Segment recycling
  const farthest = segments.reduce((m, s) => Math.max(m, s.z), 0);
  while (segments.length < SEG_COUNT) spawnSegment(farthest + SEG_LEN);
  for (let i = segments.length - 1; i >= 0; i--) {
    if (trackZ - segments[i].z > SEG_LEN * 1.5) {
      segments[i].el.parentNode.removeChild(segments[i].el);
      obstacles = obstacles.filter(o => o.parent !== segments[i].el);
      segments.splice(i, 1);
    }
  }

  // Collision
  checkCollision();

  // HUD
  document.getElementById('score-display').textContent = Math.floor(distance) + 'm';
  document.getElementById('speed-display').textContent =
    stepBoost > 0.5 ? Math.round(stepBoost / BOOST_PER_STEP * 100) + '%' : 'STOP';
  document.getElementById('meter-fill').style.width =
    Math.min(100, stepBoost / speedCap * 100) + '%';

  requestAnimationFrame(gameLoop);
}

// ============================================================
//  HEAD BOB DETECTOR
//
//  Strategy: exponential smoothing on raw Y, then track direction
//  using a confirmation counter (avoids single-frame noise triggering).
//  When direction flips from DOWN‚ÜíUP and the peak-to-valley distance
//  exceeds BOB_EXCURSION, register a step.
// ============================================================
function detectBob(rawY, dt) {
  if (smoothY === null) {
    smoothY = rawY; prevSmooth = rawY;
    peakY = rawY; valleyY = rawY; bobDir = 0; dirCount = 0;
    setVRDebug('Ready ‚Äî bob your head!');
    return;
  }

  // EMA smoothing
  smoothY += (rawY - smoothY) * BOB_ALPHA;
  const dy = smoothY - prevSmooth;
  prevSmooth = smoothY;

  // Direction confirmation counter
  if (dy > 0.00005)       dirCount = Math.min(dirCount + 1,  DIR_CONFIRM + 4);
  else if (dy < -0.00005) dirCount = Math.max(dirCount - 1, -(DIR_CONFIRM + 4));

  const confirmedDir =
    dirCount >=  DIR_CONFIRM ?  1 :
    dirCount <= -DIR_CONFIRM ? -1 :
    bobDir; // hold last confirmed direction

  if (confirmedDir !== bobDir) {
    if (confirmedDir === -1) {
      // Just started going DOWN ‚Äî record peak
      peakY = smoothY;
    }
    if (confirmedDir === 1 && bobDir === -1) {
      // Just switched from DOWN to UP ‚Äî record valley & check excursion
      valleyY = smoothY;
      const excursion = (peakY ?? smoothY) - valleyY;
      if (excursion >= BOB_EXCURSION && bobCooldown <= 0) {
        registerStep(excursion);
      }
      peakY = smoothY; // reset for next cycle
    }
    bobDir = confirmedDir;
  }

  // Continuously update running peak/valley
  if (bobDir === 1  && smoothY > (peakY   ?? -Infinity)) peakY   = smoothY;
  if (bobDir === -1 && smoothY < (valleyY ??  Infinity)) valleyY = smoothY;

  // VR debug overlay
  const curExc = (peakY !== null && valleyY !== null)
    ? Math.abs((bobDir === -1 ? (peakY - smoothY) : (smoothY - valleyY))).toFixed(3)
    : '?';
  setVRDebug(
    `Y raw:  ${rawY.toFixed(3)}\n` +
    `Y smth: ${smoothY.toFixed(3)}\n` +
    `Excur:  ${curExc} / ${BOB_EXCURSION}\n` +
    `Dir: ${bobDir > 0 ? '‚ÜëUP' : bobDir < 0 ? '‚ÜìDN' : '--'}  Steps: ${totalSteps}`
  );
}

function registerStep(excursion) {
  totalSteps++;
  bobCooldown = BOB_COOLDOWN_S;

  const boost = Math.min(BOOST_PER_STEP * (1 + excursion * 3), BOOST_PER_STEP * 1.5);
  stepBoost = Math.min(stepBoost + boost, speedCap);

  const flashEl = document.getElementById('vr-step-text');
  if (flashEl) {
    flashEl.setAttribute('value', '‚úì STEP!');
    setTimeout(() => { if (flashEl) flashEl.setAttribute('value', ''); }, 280);
  }
}

function setVRDebug(msg) {
  const el = document.getElementById('vr-debug-text');
  if (el) el.setAttribute('value', msg);
}

// ============================================================
//  KEYBOARD FALLBACK
// ============================================================
function handleKeys(dt) {
  if (keys['w'] || keys['arrowup']) {
    kbTimer += dt;
    if (kbTimer >= 0.35) {
      kbTimer = 0;
      registerStep(BOB_EXCURSION * 2);
    }
  } else {
    kbTimer = 0;
  }
}

// ============================================================
//  COLLISION
// ============================================================
function checkCollision() {
  const pMinX = playerX - 0.4, pMaxX = playerX + 0.4;
  const pMinY = 0.7, pMaxY = 1.95;

  for (const obs of obstacles) {
    // Obstacle world Z = container offset - segment Z + local Z within segment
    const wz = trackZ - obs.segZ + obs.lz;
    if (wz < -1.5 || wz > 1.5) continue;

    const hitX = pMaxX > obs.x - obs.hw && pMinX < obs.x + obs.hw;
    const hitY = pMaxY > obs.y - obs.hh && pMinY < obs.y + obs.hh;
    if (hitX && hitY) { endGame(); return; }
  }
}
</script>
</body>
</html>
