<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HEAD RUN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; font-family: 'Courier New', monospace; overflow: hidden; }
    canvas { display: block; }

    #overlay {
      position: fixed; inset: 0; z-index: 10;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,0.9); color: #00ffcc;
      pointer-events: none;
    }
    #overlay.hidden { display: none; }

    #start-screen { text-align: center; pointer-events: all; }
    h1 {
      font-size: clamp(2.5rem, 7vw, 5rem);
      letter-spacing: 0.35em; color: #00ffcc;
      text-shadow: 0 0 40px #00ffcc, 0 0 80px #00ffcc66;
      margin-bottom: 0.3rem;
    }
    .sub { font-size: 0.85rem; letter-spacing: 0.25em; color: #00ffcc55; margin-bottom: 2.5rem; }

    .card {
      background: rgba(0,255,204,0.04);
      border: 1px solid rgba(0,255,204,0.2);
      border-radius: 10px; padding: 1rem 1.4rem;
      margin-bottom: 0.7rem; max-width: 370px;
      text-align: left; font-size: 0.8rem;
      line-height: 1.75; color: #99eedd;
    }
    .card strong {
      color: #00ffcc; display: block; margin-bottom: 0.25rem;
      font-size: 0.65rem; letter-spacing: 0.18em; text-transform: uppercase;
    }

    .btn {
      display: inline-block; margin-top: 1.4rem;
      padding: 0.85rem 2.8rem;
      background: transparent; border: 2px solid #00ffcc;
      color: #00ffcc; font-family: 'Courier New', monospace;
      font-size: 0.95rem; letter-spacing: 0.3em; text-transform: uppercase;
      cursor: pointer; transition: all 0.18s;
      box-shadow: 0 0 24px rgba(0,255,204,0.12);
    }
    .btn:hover { background: rgba(0,255,204,0.08); box-shadow: 0 0 40px rgba(0,255,204,0.3); }

    #game-over { text-align: center; pointer-events: all; display: none; }
    #game-over.show { display: block; }
    #game-over h2 { font-size: clamp(2rem,5vw,3.5rem); letter-spacing: 0.3em; color: #ff3355; text-shadow: 0 0 30px #ff3355; margin-bottom: 0.8rem; }
    #final-dist { font-size: 1.1rem; color: #00ffcc; letter-spacing: 0.15em; margin-bottom: 1.5rem; }

    #hud {
      position: fixed; top: 0; left: 0; right: 0; z-index: 9;
      padding: 1rem 1.4rem; display: flex;
      justify-content: space-between; pointer-events: none;
    }
    #hud.hidden { display: none; }
    .hpanel {
      background: rgba(0,0,0,0.65);
      border: 1px solid rgba(0,255,204,0.25);
      border-radius: 6px; padding: 0.35rem 0.85rem; color: #00ffcc;
    }
    .hlabel { font-size: 0.52rem; letter-spacing: 0.2em; text-transform: uppercase; color: #00ffcc44; }
    .hval { font-size: 1.25rem; text-shadow: 0 0 8px #00ffcc; }

    #stepmeter {
      position: fixed; bottom: 1.8rem; left: 50%;
      transform: translateX(-50%); width: 170px; z-index: 9; pointer-events: none;
    }
    #stepmeter.hidden { display: none; }
    .mlabel { text-align: center; font-size: 0.52rem; letter-spacing: 0.15em; text-transform: uppercase; color: #00ffcc44; margin-bottom: 3px; }
    .mtrack { background: rgba(0,255,204,0.08); border: 1px solid rgba(0,255,204,0.25); border-radius: 20px; height: 7px; overflow: hidden; }
    #mfill { height: 100%; width: 0; border-radius: 20px; background: linear-gradient(90deg,#00ffcc,#00ff88); box-shadow: 0 0 8px #00ffcc; transition: width 0.07s; }

    #vr-btn {
      position: fixed; bottom: 1.5rem; right: 1.5rem; z-index: 20;
      padding: 0.7rem 1.6rem;
      background: rgba(0,0,0,0.8); border: 2px solid #00ffcc;
      color: #00ffcc; font-family: 'Courier New', monospace;
      font-size: 0.8rem; letter-spacing: 0.2em; text-transform: uppercase;
      cursor: pointer; border-radius: 6px;
      box-shadow: 0 0 20px rgba(0,255,204,0.2);
    }
    #vr-btn.hidden { display: none; }
  </style>
</head>
<body>

<!-- UI -->
<div id="overlay">
  <div id="start-screen">
    <h1>HEAD RUN</h1>
    <p class="sub">âˆ infinite vr runner âˆ</p>
    <div class="card">
      <strong>ğŸ® VR Movement</strong>
      Bob your head up and down to move â€” each full bob cycle propels you forward.
      Stop bobbing and you stop.
    </div>
    <div class="card">
      <strong>ğŸ–¥ï¸ Desktop</strong>
      Tap <kbd>W</kbd> rhythmically. Mouse or <kbd>A</kbd>/<kbd>D</kbd> to steer.
    </div>
    <div class="card">
      <strong>âš ï¸ Obstacles</strong>
      Dodge walls, pillars, and moving barriers. Navigate hills, ramps and stairs. Speed increases over time.
    </div>
    <button class="btn" id="start-btn">ENTER THE RUN</button>
  </div>
  <div id="game-over">
    <h2>COLLISION</h2>
    <div id="final-dist">0m</div>
    <button class="btn" id="restart-btn">RUN AGAIN</button>
  </div>
</div>

<div id="hud" class="hidden">
  <div class="hpanel"><div class="hlabel">Distance</div><div class="hval" id="hdist">0m</div></div>
  <div class="hpanel"><div class="hlabel">Speed</div><div class="hval" id="hspeed">STOP</div></div>
</div>

<div id="stepmeter" class="hidden">
  <div class="mlabel">Bob Power</div>
  <div class="mtrack"><div id="mfill"></div></div>
</div>

<button id="vr-btn" class="hidden">ENTER VR</button>

<script type="importmap">
{
  "imports": {
    "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';

// â”€â”€â”€ THREE / RENDERER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
renderer.shadowMap.enabled = false;
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
});

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050510);
scene.fog = new THREE.FogExp2(0x050510, 0.038);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
camera.position.set(0, 1.6, 0);

// Player rig â€” we move this in X for steering
const rig = new THREE.Group();
rig.add(camera);
scene.add(rig);

// Lighting
scene.add(new THREE.AmbientLight(0x001122, 0.6));
const dirLight = new THREE.DirectionalLight(0x00ffcc, 0.4);
dirLight.position.set(0, 5, -5);
scene.add(dirLight);

// â”€â”€â”€ VR SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let xrSession = null;
let xrRefSpace = null;
let inVR = false;

const vrBtn = document.getElementById('vr-btn');

async function checkVRSupport() {
  if (navigator.xr) {
    const supported = await navigator.xr.isSessionSupported('immersive-vr');
    if (supported) vrBtn.classList.remove('hidden');
  }
}
checkVRSupport();

vrBtn.addEventListener('click', async () => {
  if (xrSession) return;
  try {
    xrSession = await navigator.xr.requestSession('immersive-vr', {
      requiredFeatures: ['local-floor'],
      optionalFeatures: ['bounded-floor', 'hand-tracking']
    });
    await renderer.xr.setSession(xrSession);
    // Get floor-relative reference space for accurate Y tracking
    xrRefSpace = await xrSession.requestReferenceSpace('local-floor');
    renderer.xr.setReferenceSpace(xrRefSpace);
    inVR = true;
    vrBtn.classList.add('hidden');
    xrSession.addEventListener('end', () => {
      xrSession = null; xrRefSpace = null; inVR = false;
      vrBtn.classList.remove('hidden');
    });
  } catch(e) {
    console.error('XR session failed:', e);
  }
});

// â”€â”€â”€ CONSTANTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SEG_LEN   = 12;
const SEG_COUNT = 16;
const TW        = 6;
const TH        = 3.5;
const LANE_W    = 1.6;

const BOB_EXCURSION  = 0.0008; // metres peakâ†’valley (~0.8mm) â€” ultra sensitive for tiny head nods
const BOB_ALPHA      = 0.38;  // EMA smoothing â€” slightly higher to catch fast small movements
const DIR_CONFIRM    = 2;     // frames to confirm direction change â€” faster detection
const BOB_COOLDOWN   = 0.15;  // seconds between steps â€” shorter for rapid stepping
const BOOST_AMOUNT   = 6;     // speed units added per step
const BOOST_DECAY    = 2.5;   // speed units lost per second

// â”€â”€â”€ MATERIALS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const matWall  = new THREE.MeshLambertMaterial({ color: 0x000a22, emissive: 0x001133, side: THREE.FrontSide });
const matCeil  = new THREE.MeshLambertMaterial({ color: 0x000822, emissive: 0x000a1a });
const matObsRed  = new THREE.MeshBasicMaterial({ color: 0xff2244, transparent: true, opacity: 0.9 });
const matObsOrng = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.9 });

// Neon palette â€” each segment picks one theme
const THEMES = [
  { strip1: 0x00ffcc, strip2: 0x0055ff, arch: 0x00ffcc, floor: 0x001133 },
  { strip1: 0xff00aa, strip2: 0xff6600, arch: 0xff00aa, floor: 0x1a0011 },
  { strip1: 0x00ff44, strip2: 0x004422, arch: 0x00ff44, floor: 0x001108 },
  { strip1: 0xffcc00, strip2: 0xff4400, arch: 0xffcc00, floor: 0x1a0f00 },
  { strip1: 0xaa44ff, strip2: 0x2200ff, arch: 0xaa44ff, floor: 0x0a0022 },
];

// â”€â”€â”€ TRACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const trackContainer = new THREE.Group();
scene.add(trackContainer);

let segments        = [];
let obstacles       = [];
let movingObstacles = [];   // { mesh, type, phase, speed, segZ }
let terrainHeights  = {};   // segZ â†’ base Y offset for player height

// â”€â”€â”€ TERRAIN TYPES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 0=flat  1=hill-up  2=hill-down  3=stairs-up  4=stairs-down
function pickTerrainType(z) {
  if (z < 20) return 0;
  const r = Math.random();
  if (r < 0.52) return 0;
  if (r < 0.65) return 1;
  if (r < 0.78) return 2;
  if (r < 0.88) return 3;
  return 4;
}

function spawnSegment(z) {
  const g = new THREE.Group();
  g.position.z = -z;

  const hw = TW / 2, sl = SEG_LEN;
  const theme = THEMES[Math.floor(Math.random() * THEMES.length)];

  const mFloor = new THREE.MeshLambertMaterial({ color: theme.floor, emissive: theme.floor });
  const mS1    = new THREE.MeshBasicMaterial({ color: theme.strip1 });
  const mS2    = new THREE.MeshBasicMaterial({ color: theme.strip2 });
  const mArch  = new THREE.MeshBasicMaterial({ color: theme.arch, transparent: true, opacity: 0.85 });

  const terrainType = pickTerrainType(z);
  terrainHeights[z]  = 0;

  if (terrainType === 1 || terrainType === 2) {
    // â”€â”€ HILL / RAMP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // A wedge ramp raises or lowers the floor by RAMP_H over the segment.
    const RAMP_H = 0.65 + Math.random() * 0.35;
    const isUp   = terrainType === 1;
    terrainHeights[z] = isUp ? RAMP_H : -RAMP_H;

    // Ramp floor mesh: tilted box
    const rampGeo = new THREE.BoxGeometry(TW, 0.12, sl);
    const rampMesh = new THREE.Mesh(rampGeo, mFloor);
    rampMesh.rotation.x = (isUp ? 1 : -1) * Math.atan2(RAMP_H, sl);
    rampMesh.position.set(0, RAMP_H / 2 * (isUp ? 1 : -1), -sl / 2);
    g.add(rampMesh);

    // Neon edge strips along ramp
    const rampS1 = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.07, sl * 1.02), mS1);
    rampS1.rotation.x = rampMesh.rotation.x;
    rampS1.position.set(-hw + 0.04, RAMP_H / 2 * (isUp ? 1 : -1) + 0.06, -sl / 2);
    g.add(rampS1);
    const rampS1r = rampS1.clone();
    rampS1r.position.x = hw - 0.04;
    g.add(rampS1r);

    // Side walls stretch the full tunnel height from floor-Y=0
    addBox(g, 0.05, TH + RAMP_H + 0.1, sl, -hw, TH / 2, -sl / 2, matWall);
    addBox(g, 0.05, TH + RAMP_H + 0.1, sl,  hw, TH / 2, -sl / 2, matWall);
    addBox(g, TW, 0.05, sl, 0, TH + 0.025, -sl / 2, matCeil);
  } else if (terrainType === 3 || terrainType === 4) {
    // â”€â”€ STAIRS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const STEP_COUNT = 4;
    const STEP_H     = 0.18;
    const STEP_D     = sl / STEP_COUNT;
    const isUp       = terrainType === 3;
    terrainHeights[z] = isUp ? STEP_H * STEP_COUNT : -STEP_H * STEP_COUNT;

    for (let s = 0; s < STEP_COUNT; s++) {
      const stepIdx = isUp ? s : (STEP_COUNT - 1 - s);
      const stepY   = stepIdx * STEP_H;
      const stepZ   = -(s + 0.5) * STEP_D;

      // Tread
      addBox(g, TW, 0.1, STEP_D, 0, stepY - 0.05, stepZ, mFloor);
      // Riser
      if (isUp && s > 0) {
        const riserY = stepY / 2;
        addBox(g, TW, stepY, 0.1, 0, riserY, stepZ + STEP_D / 2, mFloor);
      } else if (!isUp && s < STEP_COUNT - 1) {
        const riserH = (STEP_COUNT - 1 - s) * STEP_H;
        addBox(g, TW, riserH, 0.1, 0, riserH / 2, stepZ + STEP_D / 2, mFloor);
      }
      // Neon edge on tread
      addBox(g, 0.07, 0.07, STEP_D, -hw + 0.04, stepY + 0.04, stepZ, mS1);
      addBox(g, 0.07, 0.07, STEP_D,  hw - 0.04, stepY + 0.04, stepZ, mS1);
    }

    const totalH = STEP_H * STEP_COUNT;
    addBox(g, 0.05, TH + totalH + 0.1, sl, -hw, TH / 2, -sl / 2, matWall);
    addBox(g, 0.05, TH + totalH + 0.1, sl,  hw, TH / 2, -sl / 2, matWall);
    addBox(g, TW, 0.05, sl, 0, TH + 0.025, -sl / 2, matCeil);
  } else {
    // â”€â”€ FLAT (default) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    addBox(g, TW, 0.05, sl,  0,       -0.025,    -sl / 2, mFloor);
    addBox(g, 0.05, TH, sl, -hw,       TH / 2,   -sl / 2, matWall);
    addBox(g, 0.05, TH, sl,  hw,       TH / 2,   -sl / 2, matWall);
    addBox(g, TW, 0.05, sl,  0,        TH + 0.025,-sl / 2, matCeil);

    // Floor neon edge strips
    addBox(g, 0.07, 0.07, sl, -hw + 0.04, 0.035,    -sl / 2, mS1);
    addBox(g, 0.07, 0.07, sl,  hw - 0.04, 0.035,    -sl / 2, mS1);
    // Ceiling neon edge strips
    addBox(g, 0.07, 0.07, sl, -hw + 0.04, TH - 0.035, -sl / 2, mS2);
    addBox(g, 0.07, 0.07, sl,  hw - 0.04, TH - 0.035, -sl / 2, mS2);

    // Floor lane dashes
    if (Math.random() < 0.6) {
      for (let d = 0; d < 3; d++) {
        addBox(g, 0.08, 0.02, 1.2, 0, 0.01, -sl * 0.15 - d * sl * 0.3, mS1);
      }
    }
  }

  // Vertical corner strips (all types)
  addBox(g, 0.07, TH, 0.07, -hw + 0.04, TH / 2, -sl * 0.1, mS1);
  addBox(g, 0.07, TH, 0.07,  hw - 0.04, TH / 2, -sl * 0.1, mS1);
  addBox(g, 0.07, TH, 0.07, -hw + 0.04, TH / 2, -sl * 0.9, mS2);
  addBox(g, 0.07, TH, 0.07,  hw - 0.04, TH / 2, -sl * 0.9, mS2);

  // Arch rings â€” 1 or 2 per segment
  const archCount = Math.random() < 0.5 ? 1 : 2;
  for (let a = 0; a < archCount; a++) {
    const az = -sl * (0.25 + a * 0.45);
    addBox(g, TW + 0.14, 0.12, 0.12,  0,           TH,    az, mArch);
    addBox(g, 0.12, TH,  0.12, -hw - 0.07, TH / 2, az, mArch);
    addBox(g, 0.12, TH,  0.12,  hw + 0.07, TH / 2, az, mArch);
  }

  // Mid-wall horizontal stripe
  if (Math.random() < 0.5) {
    const stripeY = 0.8 + Math.random() * 1.2;
    addBox(g, 0.06, 0.06, sl, -hw + 0.04, stripeY, -sl / 2, mS2);
    addBox(g, 0.06, 0.06, sl,  hw - 0.04, stripeY, -sl / 2, mS2);
  }

  // Floating ambient decoration cube (not collidable)
  if (Math.random() < 0.45) {
    const cx   = (Math.random() - 0.5) * (TW - 1.8);
    const cy   = 0.6 + Math.random() * (TH - 1.2);
    const cz   = -sl * (0.2 + Math.random() * 0.6);
    const size = 0.07 + Math.random() * 0.13;
    addBox(g, size, size, size, cx, cy, cz, mArch);
  }

  // Obstacles (skip grace zone)
  if (z > 35 && Math.random() < 0.72) spawnObstacle(g, z);

  trackContainer.add(g);
  segments.push({ group: g, z, terrainType });
}

function addBox(parent, w, h, d, x, y, z, mat) {
  const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
  m.position.set(x, y, z);
  parent.add(m);
  return m;
}

// matObsBlue â€” moving obstacle accent colour
const matObsBlue = new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.92 });
const matObsGreen = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.92 });

function spawnObstacle(parent, segZ) {
  // 0=side wall, 1=pillar, 2=low bar, 3=high bar, 4=lateral slider, 5=vertical bobber
  const type = Math.floor(Math.random() * 6);
  const lz   = -(SEG_LEN * 0.2 + Math.random() * SEG_LEN * 0.55);

  if (type === 0) {
    // Side wall with gap
    const mat = matObsRed;
    const onRight = Math.random() < 0.5;
    const bx = onRight ? TW / 4 : -TW / 4;
    const w  = TW / 2 - 0.85;
    addBox(parent, w, TH, 0.55, bx, TH / 2, lz, mat);
    obstacles.push({ segZ, lz, x: bx, hw: w / 2, y: TH / 2, hh: TH / 2, moving: false });

  } else if (type === 1) {
    // Pillar in a lane
    const mat = matObsOrng;
    const lx  = (Math.floor(Math.random() * 3) - 1) * LANE_W;
    addBox(parent, 1.1, TH, 1.1, lx, TH / 2, lz, mat);
    obstacles.push({ segZ, lz, x: lx, hw: 0.55, y: TH / 2, hh: TH / 2, moving: false });

  } else if (type === 2) {
    // Low bar (duck under)
    const mat = matObsRed;
    addBox(parent, TW - 0.5, 0.55, 0.55, 0, 0.45, lz, mat);
    obstacles.push({ segZ, lz, x: 0, hw: (TW - 0.5) / 2, y: 0.45, hh: 0.275, moving: false });

  } else if (type === 3) {
    // High bar (jump over â€” decorative, not collidable at head height)
    const mat = matObsOrng;
    addBox(parent, TW - 0.5, 0.55, 0.55, 0, TH - 0.4, lz, mat);
    obstacles.push({ segZ, lz, x: 0, hw: (TW - 0.5) / 2, y: TH - 0.4, hh: 0.275, moving: false });

  } else if (type === 4) {
    // â”€â”€ LATERAL SLIDER â€” moves left/right â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const mesh = addBox(parent, 1.2, TH * 0.7, 0.55, 0, TH * 0.35, lz, matObsBlue);
    const speed = 1.2 + Math.random() * 1.6;
    const phase = Math.random() * Math.PI * 2;
    movingObstacles.push({
      mesh, segZ, lz,
      type: 'lateral',
      phase, speed,
      hw: 0.6, hh: TH * 0.35,
      amplitude: TW / 2 - 0.8,
    });
    obstacles.push({ segZ, lz, x: 0, hw: 0.6, y: TH * 0.35, hh: TH * 0.35, moving: true, movingRef: movingObstacles[movingObstacles.length - 1] });

  } else {
    // â”€â”€ VERTICAL BOBBER â€” moves up/down â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const mesh = addBox(parent, TW - 0.6, 0.5, 0.55, 0, 0.8, lz, matObsGreen);
    const speed = 0.9 + Math.random() * 1.2;
    const phase = Math.random() * Math.PI * 2;
    movingObstacles.push({
      mesh, segZ, lz,
      type: 'vertical',
      phase, speed,
      hw: (TW - 0.6) / 2, hh: 0.25,
      minY: 0.35, maxY: TH - 0.6,
    });
    obstacles.push({ segZ, lz, x: 0, hw: (TW - 0.6) / 2, y: 0.8, hh: 0.25, moving: true, movingRef: movingObstacles[movingObstacles.length - 1] });
  }
}

function buildTrack() {
  for (let i = 0; i < SEG_COUNT; i++) spawnSegment(i * SEG_LEN);
}

// â”€â”€â”€ STUN OVERLAY (red plane in front of camera) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const stunMat   = new THREE.MeshBasicMaterial({ color: 0xff1122, transparent: true, opacity: 0, depthTest: false, depthWrite: false });
const stunPlane = new THREE.Mesh(new THREE.PlaneGeometry(3, 3), stunMat);
stunPlane.position.set(0, 0, -0.55);
stunPlane.renderOrder = 997;
camera.add(stunPlane);

const origBgColor  = new THREE.Color(0x050510);
const origFogColor = new THREE.Color(0x050510);
const stunRedColor = new THREE.Color(0x3a0005);

function playCollisionSound() {
  if (!audioCtx) return;
  const t = audioCtx.currentTime;
  // Low thud
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.connect(g); g.connect(masterGain);
  o.frequency.setValueAtTime(90, t);
  o.frequency.exponentialRampToValueAtTime(28, t + 0.45);
  g.gain.setValueAtTime(1.6, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
  o.start(t); o.stop(t + 0.5);
  // Noise crunch
  const bufSize = Math.floor(audioCtx.sampleRate * 0.25);
  const buf  = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / bufSize);
  const src = audioCtx.createBufferSource();
  src.buffer = buf;
  const lp = audioCtx.createBiquadFilter();
  lp.type = 'lowpass'; lp.frequency.value = 700;
  const ng = audioCtx.createGain();
  src.connect(lp); lp.connect(ng); ng.connect(masterGain);
  ng.gain.setValueAtTime(1.2, t);
  ng.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
  src.start(t); src.stop(t + 0.25);
}

function stunPlayer() {
  if (stunTimer > 0 || stunCooldown > 0) return;
  stepBoost  = 0;
  stunTimer  = STUN_DURATION;
  playCollisionSound();
}

// â”€â”€â”€ IN-VR DEBUG SPRITE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// A canvas texture attached to the camera so it's always in view
const dbgCanvas  = document.createElement('canvas');
dbgCanvas.width  = 512; dbgCanvas.height = 256;
const dbgCtx     = dbgCanvas.getContext('2d');
const dbgTex     = new THREE.CanvasTexture(dbgCanvas);
const dbgMat     = new THREE.MeshBasicMaterial({ map: dbgTex, transparent: true, depthTest: false });
const dbgPlane   = new THREE.Mesh(new THREE.PlaneGeometry(0.45, 0.22), dbgMat);
dbgPlane.position.set(0, -0.28, -0.65);
dbgPlane.renderOrder = 999;
camera.add(dbgPlane);

function updateDebugCanvas(lines, stepFlash) {
  const c = dbgCtx;
  c.clearRect(0, 0, 512, 256);
  c.fillStyle = 'rgba(0,0,16,0.78)';
  roundRect(c, 0, 0, 512, 256, 18);
  c.fill();
  c.font = 'bold 32px monospace';
  c.fillStyle = stepFlash ? '#ffffff' : '#00ffcc';
  lines.forEach((l, i) => c.fillText(l, 20, 44 + i * 42));
  if (stepFlash) {
    c.fillStyle = '#ffffff';
    c.font = 'bold 38px monospace';
    c.fillText('âœ“ STEP!', 280, 220);
  }
  dbgTex.needsUpdate = true;
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y); ctx.arcTo(x+w, y, x+w, y+r, r);
  ctx.lineTo(x+w, y+h-r); ctx.arcTo(x+w, y+h, x+w-r, y+h, r);
  ctx.lineTo(x+r, y+h); ctx.arcTo(x, y+h, x, y+h-r, r);
  ctx.lineTo(x, y+r); ctx.arcTo(x, y, x+r, y, r);
  ctx.closePath();
}

// â”€â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let gameActive = false;
let gameOver   = false;
let trackZ     = 0;
let playerX    = 0;
let distance   = 0;
let stepBoost  = 0;
let speedCap   = 14;

// Stun state (VR-only collision recovery)
const STUN_DURATION  = 1.2;  // seconds the stun lasts
const STUN_RECOOL    = 1.5;  // seconds before you can be stunned again
let stunTimer    = 0;
let stunCooldown = 0;

// Bob detection
let smoothY    = null;
let prevSmooth = null;
let peakY      = null;
let valleyY    = null;
let bobDir     = 0;
let dirCount   = 0;
let bobCooldown = 0;
let totalSteps  = 0;
let stepFlash   = 0;

// Keyboard
let keys   = {};
let kbTimer = 0;

window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup',   e => keys[e.key.toLowerCase()] = false);

// Mouse look (desktop)
let yaw = 0;
let isPointerLocked = false;
renderer.domElement.addEventListener('click', () => {
  if (!inVR && gameActive) renderer.domElement.requestPointerLock();
});
document.addEventListener('pointerlockchange', () => {
  isPointerLocked = document.pointerLockElement === renderer.domElement;
});
document.addEventListener('mousemove', e => {
  if (isPointerLocked && !inVR) {
    yaw -= e.movementX * 0.002;
    camera.rotation.y = yaw;
  }
});

// â”€â”€â”€ PROCEDURAL MUSIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Web Audio API step-synced generative music.
// BPM tracks the player's bob pace â€” faster walking = faster beat.

let audioCtx    = null;
let masterGain  = null;
let musicActive = false;

let currentBPM    = 80;
const MIN_BPM     = 70;
const MAX_BPM     = 160;
const BPM_PER_STEP = 8;
const BPM_DECAY   = 12;

let nextBeatTime   = 0;
let beatIndex      = 0;
const SCHEDULE_AHEAD = 0.12;
let schedulerTimer = null;

const kickPat  = [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0];
const snarePat = [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0];
const hihatPat = [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0];
const openHat  = [0,0,0,0, 0,0,0,1, 0,0,0,0, 0,0,0,1];
const bassPat  = [0,0,12,0, 0,0,7,0, 0,0,10,0, 0,0,5,0];

function initAudio() {
  if (audioCtx) return;
  audioCtx   = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.setValueAtTime(0.0, audioCtx.currentTime);
  masterGain.connect(audioCtx.destination);
}

function startMusic() {
  initAudio();
  if (audioCtx.state === 'suspended') audioCtx.resume();
  musicActive  = true;
  beatIndex    = 0;
  nextBeatTime = audioCtx.currentTime + 0.1;
  masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
  masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
  masterGain.gain.linearRampToValueAtTime(1.0, audioCtx.currentTime + 1.5);
  schedulerTimer = setInterval(scheduleBeats, 50);
}

function stopMusic() {
  musicActive = false;
  clearInterval(schedulerTimer);
  if (!masterGain) return;
  masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
  masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
  masterGain.gain.linearRampToValueAtTime(0.0, audioCtx.currentTime + 1.2);
}

function scheduleBeats() {
  if (!musicActive || !audioCtx) return;
  const stepDur = 60 / currentBPM / 4;
  const lookahead = audioCtx.currentTime + SCHEDULE_AHEAD;
  while (nextBeatTime < lookahead) {
    const t = nextBeatTime;
    const i = beatIndex % 16;
    if (kickPat[i])  scheduleKick(t);
    if (snarePat[i]) scheduleSnare(t);
    if (hihatPat[i]) scheduleHihat(t, false);
    if (openHat[i])  scheduleHihat(t, true);
    if (bassPat[i])  scheduleBass(t, bassPat[i]);
    nextBeatTime += stepDur;
    beatIndex++;
  }
}

function updateMusicBPM(dt) {
  if (!musicActive) return;
  currentBPM = Math.max(MIN_BPM, currentBPM - BPM_DECAY * dt);
}

function onStepMusic() {
  if (!musicActive) return;
  currentBPM = Math.min(MAX_BPM, currentBPM + BPM_PER_STEP);
}

function scheduleKick(t) {
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.connect(g); g.connect(masterGain);
  o.frequency.setValueAtTime(150, t);
  o.frequency.exponentialRampToValueAtTime(40, t + 0.12);
  g.gain.setValueAtTime(1.2, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
  o.start(t); o.stop(t + 0.35);
}

function scheduleSnare(t) {
  const bufSize = audioCtx.sampleRate * 0.18;
  const buf  = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
  const src    = audioCtx.createBufferSource();
  src.buffer   = buf;
  const filter = audioCtx.createBiquadFilter();
  filter.type  = 'bandpass'; filter.frequency.value = 2200; filter.Q.value = 0.8;
  const g = audioCtx.createGain();
  src.connect(filter); filter.connect(g); g.connect(masterGain);
  g.gain.setValueAtTime(0.55, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
  src.start(t); src.stop(t + 0.18);
  const o = audioCtx.createOscillator();
  const og = audioCtx.createGain();
  o.connect(og); og.connect(masterGain);
  o.frequency.setValueAtTime(200, t);
  og.gain.setValueAtTime(0.3, t);
  og.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
  o.start(t); o.stop(t + 0.1);
}

function scheduleHihat(t, open) {
  const dur = open ? 0.25 : 0.04;
  const bufSize = audioCtx.sampleRate * dur;
  const buf  = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
  const src    = audioCtx.createBufferSource();
  src.buffer   = buf;
  const filter = audioCtx.createBiquadFilter();
  filter.type  = 'highpass'; filter.frequency.value = 7000;
  const g = audioCtx.createGain();
  src.connect(filter); filter.connect(g); g.connect(masterGain);
  g.gain.setValueAtTime(open ? 0.18 : 0.12, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur);
  src.start(t); src.stop(t + dur);
}

function scheduleBass(t, semitones) {
  const freq = 55 * Math.pow(2, semitones / 12);
  const o  = audioCtx.createOscillator();
  const lp = audioCtx.createBiquadFilter();
  const g  = audioCtx.createGain();
  lp.type = 'lowpass'; lp.frequency.value = 400;
  o.type  = 'sawtooth';
  o.connect(lp); lp.connect(g); g.connect(masterGain);
  o.frequency.setValueAtTime(freq, t);
  g.gain.setValueAtTime(0.0, t);
  g.gain.linearRampToValueAtTime(0.4, t + 0.01);
  g.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
  o.start(t); o.stop(t + 0.2);
}

// â”€â”€â”€ GAME CONTROL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startGame() {
  document.getElementById('overlay').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  document.getElementById('stepmeter').classList.remove('hidden');
  document.getElementById('start-screen').style.display = 'block';

  gameActive = true; gameOver = false;
  trackZ = 0; playerX = 0; distance = 0;
  stepBoost = 0; speedCap = 6;
  totalSteps = 0; kbTimer = 0;
  smoothY = null; prevSmooth = null;
  peakY = null; valleyY = null;
  bobDir = 0; dirCount = 0; bobCooldown = 0; stepFlash = 0;
  stunTimer = 0; stunCooldown = 0;
  stunMat.opacity = 0;
  scene.background.copy(origBgColor);
  scene.fog.color.copy(origFogColor);
  yaw = 0; camera.rotation.set(0, 0, 0);

  // Clear track
  while (trackContainer.children.length) trackContainer.remove(trackContainer.children[0]);
  segments = []; obstacles = []; movingObstacles = []; terrainHeights = {};
  rig.position.set(0, 0, 0);
  buildTrack();
  startMusic();
}

function endGame() {
  if (gameOver) return;
  gameOver = true; gameActive = false;
  stopMusic();
  document.getElementById('hud').classList.add('hidden');
  document.getElementById('stepmeter').classList.add('hidden');
  document.getElementById('final-dist').textContent = 'DISTANCE: ' + Math.floor(distance) + 'm';
  document.getElementById('overlay').classList.remove('hidden');
  document.getElementById('game-over').classList.add('show');
  document.getElementById('start-screen').style.display = 'none';
}

function restartGame() {
  document.getElementById('game-over').classList.remove('show');
  startGame();
}

document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', restartGame);

// â”€â”€â”€ BOB DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function detectBob(rawY, dt) {
  if (smoothY === null) {
    smoothY = rawY; prevSmooth = rawY;
    peakY = rawY; valleyY = rawY; bobDir = 0; dirCount = 0;
    return;
  }

  smoothY += (rawY - smoothY) * BOB_ALPHA;
  const dy = smoothY - prevSmooth;
  prevSmooth = smoothY;

  // Accumulate direction confirmation
  if      (dy >  0.00005) dirCount = Math.min(dirCount + 1,  DIR_CONFIRM + 6);
  else if (dy < -0.00005) dirCount = Math.max(dirCount - 1, -(DIR_CONFIRM + 6));

  const newDir =
    dirCount >=  DIR_CONFIRM ?  1 :
    dirCount <= -DIR_CONFIRM ? -1 : bobDir;

  if (newDir !== bobDir && newDir !== 0) {
    if (newDir === -1) {
      // Turned downward â€” record peak
      peakY = smoothY;
    }
    if (newDir === 1 && bobDir === -1) {
      // Turned upward after going down â€” check excursion
      valleyY = smoothY;
      const excursion = (peakY ?? smoothY) - valleyY;
      if (excursion >= BOB_EXCURSION && bobCooldown <= 0) {
        registerStep(excursion);
      }
      peakY = smoothY;
    }
    bobDir = newDir;
  }

  // Track running peak/valley
  if (bobDir ===  1 && smoothY > (peakY   ?? -Infinity)) peakY   = smoothY;
  if (bobDir === -1 && smoothY < (valleyY ??  Infinity)) valleyY = smoothY;
}

function registerStep(excursion) {
  totalSteps++;
  bobCooldown = BOB_COOLDOWN;
  const boost = Math.min(BOOST_AMOUNT * (1 + excursion * 4), BOOST_AMOUNT * 1.5);
  stepBoost = Math.min(stepBoost + boost, speedCap);
  stepFlash = 0.3;
  onStepMusic();
}

// â”€â”€â”€ COLLISION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkCollision() {
  const px = playerX;
  const pMinX = px - 0.38, pMaxX = px + 0.38;
  const pMinY = 0.65,      pMaxY = 2.0;

  for (const obs of obstacles) {
    // Container is at +trackZ. Segment is at -obs.segZ within container.
    // Obstacle is at obs.lz within segment. Player sits at world Z=0.
    // Obstacle world Z = trackZ - obs.segZ + obs.lz
    // Passes player when this â‰ˆ 0, i.e. trackZ â‰ˆ segZ - lz
    const wz = trackZ - obs.segZ + obs.lz;
    if (wz < -1.8 || wz > 1.0) continue;

    if (pMaxX > obs.x - obs.hw && pMinX < obs.x + obs.hw &&
        pMaxY > obs.y - obs.hh && pMinY < obs.y + obs.hh) {
      if (inVR) { stunPlayer(); return; }
      else       { endGame();   return; }
    }
  }
}

// â”€â”€â”€ MAIN RENDER LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastTime = null;

renderer.setAnimationLoop((time, frame) => {
  const now = time / 1000;
  const dt = lastTime !== null ? Math.min(now - lastTime, 0.05) : 0;
  lastTime = now;

  if (!gameActive) {
    renderer.render(scene, camera);
    return;
  }

  // â”€â”€ HEAD Y from XR frame (VR) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let headY = camera.getWorldPosition(new THREE.Vector3()).y;

  if (inVR && frame && xrRefSpace) {
    try {
      const pose = frame.getViewerPose(xrRefSpace);
      if (pose) {
        // This is the real physical head Y in metres above the floor
        headY = pose.transform.position.y;
      }
    } catch(e) {}
  }

  detectBob(headY, dt);
  if (bobCooldown > 0) bobCooldown -= dt;
  if (stepFlash   > 0) stepFlash   -= dt;

  // â”€â”€ Keyboard steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (keys['w'] || keys['arrowup']) {
    kbTimer += dt;
    if (kbTimer >= 0.32) { kbTimer = 0; registerStep(BOB_EXCURSION * 2); }
  } else kbTimer = 0;

  // â”€â”€ Steering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let steer = 0;
  if (keys['a'] || keys['arrowleft'])  steer = -1;
  if (keys['d'] || keys['arrowright']) steer =  1;

  if (steer === 0) {
    // Use camera look direction for steering (works in VR naturally)
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    steer = Math.max(-1, Math.min(1, dir.x * 2.5));
  }

  playerX = Math.max(-TW/2 + 0.55, Math.min(TW/2 - 0.55, playerX + steer * 4 * dt));
  rig.position.x = playerX;

  // â”€â”€ Forward movement â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  trackZ   += stepBoost * dt;
  distance += stepBoost * dt;
  stepBoost = Math.max(0, stepBoost - BOOST_DECAY * dt);
  updateMusicBPM(dt);
  speedCap  = Math.min(14, 6 + distance * 0.003);
  trackContainer.position.z = trackZ;

  // â”€â”€ Animate moving obstacles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (const mo of movingObstacles) {
    mo.phase += mo.speed * dt;
    if (mo.type === 'lateral') {
      mo.mesh.position.x = Math.sin(mo.phase) * mo.amplitude;
    } else if (mo.type === 'vertical') {
      const mid = (mo.minY + mo.maxY) / 2;
      const amp = (mo.maxY - mo.minY) / 2;
      mo.mesh.position.y = mid + Math.sin(mo.phase) * amp;
    }
  }
  // Sync obstacle AABB x/y for moving types
  for (const obs of obstacles) {
    if (obs.moving && obs.movingRef) {
      const mo = obs.movingRef;
      if (mo.type === 'lateral') obs.x  = mo.mesh.position.x;
      if (mo.type === 'vertical') obs.y  = mo.mesh.position.y;
    }
  }

  // â”€â”€ Camera height from terrain â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Find the segment the player is currently on
  let terrainY = 0;
  {
    const playerWorldZ = trackZ;
    let bestSeg = null, bestDist = Infinity;
    for (const seg of segments) {
      const segWorldZ = playerWorldZ - seg.z; // how far past segment start
      if (segWorldZ >= 0 && segWorldZ < SEG_LEN) {
        bestSeg  = seg;
        bestDist = 0;
        break;
      }
      const d = Math.abs(segWorldZ);
      if (d < bestDist) { bestDist = d; bestSeg = seg; }
    }
    if (bestSeg) {
      const th = terrainHeights[bestSeg.z] ?? 0;
      if (bestSeg.terrainType === 1 || bestSeg.terrainType === 2) {
        // Interpolate ramp height based on how far along the segment
        const t = Math.max(0, Math.min(1, (trackZ - bestSeg.z) / SEG_LEN));
        const frac = bestSeg.terrainType === 1 ? t : 1 - t;
        terrainY = th * frac;
      } else if (bestSeg.terrainType === 3 || bestSeg.terrainType === 4) {
        const STEP_COUNT = 4;
        const STEP_H     = 0.18;
        const t = Math.max(0, Math.min(1, (trackZ - bestSeg.z) / SEG_LEN));
        const stepIdx = bestSeg.terrainType === 3
          ? Math.floor(t * STEP_COUNT)
          : STEP_COUNT - 1 - Math.floor(t * STEP_COUNT);
        terrainY = stepIdx * STEP_H;
      }
    }
  }
  // Smoothly adjust rig Y to terrain height
  rig.position.y += (terrainY - rig.position.y) * Math.min(1, dt * 10);

  // â”€â”€ Stun tick + red-flash visual â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (stunCooldown > 0) stunCooldown -= dt;
  if (stunTimer > 0) {
    stunTimer -= dt;
    stepBoost  = 0; // keep player stopped throughout stun
    if (stunTimer <= 0) { stunTimer = 0; stunCooldown = STUN_RECOOL; }
  }
  {
    const f = Math.max(0, stunTimer / STUN_DURATION); // 1â†’0 during stun
    stunMat.opacity = f * 0.55;
    scene.background.copy(origBgColor).lerp(stunRedColor, f * 0.8);
    scene.fog.color.copy(origFogColor).lerp(stunRedColor, f * 0.8);
  }

  // â”€â”€ Segment recycling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const farthest = segments.reduce((m, s) => Math.max(m, s.z), 0);
  while (segments.length < SEG_COUNT) spawnSegment(farthest + SEG_LEN);

  for (let i = segments.length - 1; i >= 0; i--) {
    const passed = trackZ - segments[i].z;
    if (passed > SEG_LEN * 2) {
      const deadZ = segments[i].z;
      trackContainer.remove(segments[i].group);
      segments[i].group.traverse(o => {
        if (o.geometry) o.geometry.dispose();
        if (o.material && o.material.dispose) o.material.dispose();
      });
      obstacles       = obstacles.filter(o => o.segZ !== deadZ);
      movingObstacles = movingObstacles.filter(o => o.segZ !== deadZ);
      delete terrainHeights[deadZ];
      segments.splice(i, 1);
    }
  }

  // â”€â”€ Collision â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  checkCollision();

  // â”€â”€ HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  document.getElementById('hdist').textContent  = Math.floor(distance) + 'm';
  document.getElementById('hspeed').textContent =
    stepBoost > 0.5 ? Math.round(stepBoost / BOOST_AMOUNT * 100) + '%' : 'STOP';
  document.getElementById('mfill').style.width  =
    Math.min(100, stepBoost / speedCap * 100) + '%';

  // â”€â”€ VR debug canvas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const curExc = (peakY !== null && valleyY !== null)
    ? Math.abs(peakY - (valleyY ?? peakY)).toFixed(3) : '-.---';
  updateDebugCanvas([
    `Y: ${headY.toFixed(3)}m`,
    `Exc: ${curExc} / ${BOB_EXCURSION}`,
    `Dir: ${bobDir > 0 ? 'â†‘ UP' : bobDir < 0 ? 'â†“ DN' : '-- --'}`,
    `Steps: ${totalSteps}   Cool: ${bobCooldown > 0 ? bobCooldown.toFixed(2)+'s' : 'OK'}`,
    `Boost: ${stepBoost.toFixed(1)}  BPM: ${Math.round(currentBPM)}`,
  ], stepFlash > 0);

  renderer.render(scene, camera);
});

// Initial debug canvas
updateDebugCanvas(['Press START to begin', '', '', '', ''], false);

</script>
</body>
</html>
