<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HEAD RUN ‚Äî VR Infinite Runner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/aframe/1.4.2/aframe.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; font-family: 'Courier New', monospace; overflow: hidden; }

    #ui-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      color: #00ffcc;
      pointer-events: none;
    }

    #ui-overlay.hidden { display: none; }

    #start-screen {
      text-align: center;
      pointer-events: all;
    }

    #start-screen h1 {
      font-size: clamp(2rem, 6vw, 4rem);
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: #00ffcc;
      text-shadow: 0 0 30px #00ffcc, 0 0 60px #00ffcc88;
      margin-bottom: 0.5rem;
    }

    #start-screen .subtitle {
      font-size: clamp(0.7rem, 2vw, 1rem);
      letter-spacing: 0.2em;
      color: #00ffcc88;
      margin-bottom: 3rem;
    }

    .instruction {
      background: rgba(0,255,204,0.05);
      border: 1px solid rgba(0,255,204,0.3);
      border-radius: 8px;
      padding: 1.5rem 2rem;
      margin-bottom: 1rem;
      max-width: 400px;
      text-align: left;
      font-size: 0.85rem;
      line-height: 1.8;
      color: #aaffee;
    }

    .instruction strong {
      color: #00ffcc;
      display: block;
      margin-bottom: 0.5rem;
      font-size: 0.75rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
    }

    #start-btn {
      margin-top: 2rem;
      padding: 1rem 3rem;
      background: transparent;
      border: 2px solid #00ffcc;
      color: #00ffcc;
      font-family: 'Courier New', monospace;
      font-size: 1rem;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 0 20px rgba(0,255,204,0.2);
    }

    #start-btn:hover {
      background: rgba(0,255,204,0.1);
      box-shadow: 0 0 40px rgba(0,255,204,0.4);
    }

    #hud {
      position: fixed;
      top: 0; left: 0; right: 0;
      z-index: 50;
      padding: 1rem 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
    }

    #hud.hidden { display: none; }

    .hud-panel {
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(0,255,204,0.3);
      border-radius: 6px;
      padding: 0.5rem 1rem;
      color: #00ffcc;
    }

    .hud-label {
      font-size: 0.6rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: #00ffcc66;
    }

    .hud-value {
      font-size: 1.4rem;
      letter-spacing: 0.1em;
      text-shadow: 0 0 10px #00ffcc;
    }

    #bob-meter {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
      width: 200px;
      pointer-events: none;
    }

    #bob-meter.hidden { display: none; }

    .meter-label {
      text-align: center;
      font-size: 0.6rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: #00ffcc66;
      margin-bottom: 0.3rem;
    }

    .meter-bar-bg {
      background: rgba(0,255,204,0.1);
      border: 1px solid rgba(0,255,204,0.3);
      border-radius: 20px;
      height: 8px;
      overflow: hidden;
    }

    #meter-fill {
      height: 100%;
      background: linear-gradient(90deg, #00ffcc, #00ff88);
      border-radius: 20px;
      width: 0%;
      transition: width 0.1s;
      box-shadow: 0 0 10px #00ffcc;
    }

    #game-over-screen {
      text-align: center;
      pointer-events: all;
      display: none;
    }

    #game-over-screen.visible { display: block; }

    #game-over-screen h2 {
      font-size: clamp(1.5rem, 5vw, 3rem);
      letter-spacing: 0.3em;
      color: #ff4466;
      text-shadow: 0 0 30px #ff4466;
      margin-bottom: 1rem;
    }

    #final-score {
      font-size: 1.2rem;
      color: #00ffcc;
      margin-bottom: 2rem;
      letter-spacing: 0.2em;
    }

    #restart-btn {
      padding: 0.8rem 2.5rem;
      background: transparent;
      border: 2px solid #00ffcc;
      color: #00ffcc;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s;
    }

    #restart-btn:hover {
      background: rgba(0,255,204,0.1);
    }

    #debug-panel {
      position: fixed;
      bottom: 5rem;
      right: 1rem;
      z-index: 50;
      background: rgba(0,0,0,0.7);
      border: 1px solid rgba(0,255,204,0.2);
      border-radius: 6px;
      padding: 0.5rem 0.8rem;
      color: #00ffcc66;
      font-size: 0.65rem;
      letter-spacing: 0.1em;
      pointer-events: none;
      display: none;
    }

    #non-vr-hint {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      z-index: 50;
      color: rgba(0,255,204,0.4);
      font-size: 0.65rem;
      letter-spacing: 0.1em;
      pointer-events: none;
    }

    #non-vr-hint.hidden { display: none; }
  </style>
</head>
<body>

<!-- UI Overlay -->
<div id="ui-overlay">
  <div id="start-screen">
    <h1>HEAD RUN</h1>
    <p class="subtitle">‚àû infinite vr runner ‚àû</p>

    <div class="instruction">
      <strong>üéÆ How to Move</strong>
      Bob your head up and down like you're walking ‚Äî each bob cycle propels you forward. Stop bobbing and you'll stop moving.
    </div>

    <div class="instruction">
      <strong>‚ö†Ô∏è Dodge Obstacles</strong>
      Look left or right to steer around incoming walls and barriers. Speed increases as you progress.
    </div>

    <div class="instruction">
      <strong>üíª No Headset?</strong>
      Tap <kbd>W</kbd> rhythmically to simulate walking steps. Use <kbd>A</kbd> / <kbd>D</kbd> or mouse to steer.
    </div>

    <button id="start-btn" onclick="startGame()">ENTER THE RUN</button>
  </div>

  <div id="game-over-screen">
    <h2>COLLISION</h2>
    <div id="final-score">DISTANCE: 0m</div>
    <button id="restart-btn" onclick="restartGame()">RUN AGAIN</button>
  </div>
</div>

<!-- HUD -->
<div id="hud" class="hidden">
  <div class="hud-panel">
    <div class="hud-label">Distance</div>
    <div class="hud-value" id="score-display">0m</div>
  </div>
  <div class="hud-panel">
    <div class="hud-label">Speed</div>
    <div class="hud-value" id="speed-display">1.0x</div>
  </div>
</div>

<!-- Bob Meter -->
<div id="bob-meter" class="hidden">
  <div class="meter-label">Step Meter</div>
  <div class="meter-bar-bg">
    <div id="meter-fill"></div>
  </div>
</div>

<div id="debug-panel">
  HEAD Y: <span id="debug-y">0.000</span><br>
  BOB: <span id="debug-bob">0.000</span><br>
  STEPS: <span id="debug-steps">0</span>
</div>

<div id="non-vr-hint">
  No VR? Use W/A/D keys or mouse
</div>

<!-- A-Frame Scene -->
<a-scene id="scene"
  background="color: #050510"
  fog="type: exponential; color: #050510; density: 0.04"
  vr-mode-ui="enabled: true"
  renderer="antialias: true; colorManagement: true; physicallyCorrectLights: true">

  <a-assets>
    <!-- Nothing to preload, all procedural -->
  </a-assets>

  <!-- Camera Rig -->
  <a-entity id="rig" position="0 0 0">
    <a-camera id="head-cam"
      position="0 1.6 0"
      look-controls="pointerLockEnabled: false"
      wasd-controls="enabled: false">

      <!-- Crosshair / reticle -->
      <a-entity id="reticle"
        position="0 0 -3"
        geometry="primitive: ring; radiusInner: 0.01; radiusOuter: 0.02"
        material="color: #00ffcc; opacity: 0.7; shader: flat"
        visible="true">
      </a-entity>

      <!-- In-VR debug panel (floats in view) -->
      <a-entity id="vr-debug-panel" position="-0.35 -0.25 -0.8">
        <a-plane
          width="0.5" height="0.28"
          material="color: #000000; opacity: 0.75; shader: flat; transparent: true">
        </a-plane>
        <a-text id="vr-debug-text"
          value="Initializing..."
          color="#00ffcc"
          width="0.9"
          align="left"
          anchor="left"
          position="-0.23 0.08 0.01"
          wrap-count="28"
          font="mozillavr">
        </a-text>
        <a-text id="vr-step-flash"
          value=""
          color="#ffffff"
          width="1.2"
          align="center"
          position="0 -0.1 0.01"
          font="mozillavr">
        </a-text>
      </a-entity>
    </a-camera>
  </a-entity>

  <!-- Track container - we move this backward to simulate forward movement -->
  <a-entity id="track-container" position="0 0 0">
    <!-- Track segments spawned here by JS -->
  </a-entity>

  <!-- Ambient + directional light -->
  <a-light type="ambient" color="#001122" intensity="0.5"></a-light>
  <a-light type="directional" color="#00ffcc" intensity="0.3" position="0 5 -5"></a-light>

  <!-- Neon glow fog plane at ground -->
  <a-plane
    position="0 0 -50"
    rotation="-90 0 0"
    width="20" height="200"
    material="color: #000822; shader: flat; opacity: 0.95"
    visible="true">
  </a-plane>

</a-scene>

<script>
// ============================================================
//  GAME STATE
// ============================================================
const LANE_WIDTH = 1.4;       // half-width of lane offset (3 lanes: -LANE_WIDTH, 0, LANE_WIDTH)
const SEGMENT_LENGTH = 10;    // Z length of each track segment
const SEGMENT_COUNT = 12;     // how many segments ahead
const TRACK_WIDTH = 6;
const TRACK_HEIGHT = 3.5;

let gameActive = false;
let gameOver = false;
let score = 0;
let baseSpeed = 5;            // constant forward speed (units/sec)
let stepBoost = 0;            // extra speed burst from head-bob steps
let trackZ = 0;               // total distance traveled (track moves in -Z direction)
let segments = [];            // array of { entity, z, hasObstacle }
let obstacles = [];           // obstacle entities

// Head bob detection
let lastHeadY = null;
let headYHistory = [];
let bobPhase = 'idle';
let bobThreshold = 0.015;
let bobCooldown = 0;
let totalSteps = 0;
let bobDisplay = 0;

// Keyboard fallback
let keys = {};
let kbBobTimer = 0;

// Lateral steer
let playerLaneX = 0;          // actual X offset of camera rig

// Scoring
let distanceTraveled = 0;

// ============================================================
//  INIT
// ============================================================
window.addEventListener('DOMContentLoaded', () => {
  document.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
  document.addEventListener('keyup',   e => { keys[e.key.toLowerCase()] = false; });

  const scene = document.getElementById('scene');
  scene.addEventListener('loaded', () => {
    buildInitialTrack();
  });
});

function buildInitialTrack() {
  for (let i = 0; i < SEGMENT_COUNT; i++) {
    spawnSegment(i * SEGMENT_LENGTH);
  }
}

// ============================================================
//  TRACK GENERATION
// ============================================================
function spawnSegment(zOffset) {
  const container = document.getElementById('track-container');

  const seg = document.createElement('a-entity');
  // Segments are placed ahead of the player in -Z (into screen)
  seg.setAttribute('position', `0 0 -${zOffset}`);

  // Floor
  const floor = document.createElement('a-plane');
  floor.setAttribute('rotation', '-90 0 0');
  floor.setAttribute('width', TRACK_WIDTH);
  floor.setAttribute('height', SEGMENT_LENGTH);
  floor.setAttribute('position', `0 0 -${SEGMENT_LENGTH / 2}`);
  floor.setAttribute('material', `color: #001133; metalness: 0.8; roughness: 0.3; emissive: #000511; emissiveIntensity: 0.3`);
  seg.appendChild(floor);

  // Left wall
  const wallL = document.createElement('a-plane');
  wallL.setAttribute('rotation', '0 90 0');
  wallL.setAttribute('width', SEGMENT_LENGTH);
  wallL.setAttribute('height', TRACK_HEIGHT);
  wallL.setAttribute('position', `${-TRACK_WIDTH/2} ${TRACK_HEIGHT/2} -${SEGMENT_LENGTH/2}`);
  wallL.setAttribute('material', `color: #000a22; emissive: #001133; emissiveIntensity: 0.5`);
  seg.appendChild(wallL);

  // Right wall
  const wallR = document.createElement('a-plane');
  wallR.setAttribute('rotation', '0 -90 0');
  wallR.setAttribute('width', SEGMENT_LENGTH);
  wallR.setAttribute('height', TRACK_HEIGHT);
  wallR.setAttribute('position', `${TRACK_WIDTH/2} ${TRACK_HEIGHT/2} -${SEGMENT_LENGTH/2}`);
  wallR.setAttribute('material', `color: #000a22; emissive: #001133; emissiveIntensity: 0.5`);
  seg.appendChild(wallR);

  // Ceiling
  const ceil = document.createElement('a-plane');
  ceil.setAttribute('rotation', '90 0 0');
  ceil.setAttribute('width', TRACK_WIDTH);
  ceil.setAttribute('height', SEGMENT_LENGTH);
  ceil.setAttribute('position', `0 ${TRACK_HEIGHT} -${SEGMENT_LENGTH/2}`);
  ceil.setAttribute('material', `color: #000822; emissive: #000a1a; emissiveIntensity: 0.3`);
  seg.appendChild(ceil);

  // Neon edge strips
  spawnNeonStrip(seg, -TRACK_WIDTH/2 + 0.05, 0.05, '#00ffcc');
  spawnNeonStrip(seg,  TRACK_WIDTH/2 - 0.05, 0.05, '#00ffcc');
  spawnNeonStrip(seg, -TRACK_WIDTH/2 + 0.05, TRACK_HEIGHT - 0.05, '#0088ff');
  spawnNeonStrip(seg,  TRACK_WIDTH/2 - 0.05, TRACK_HEIGHT - 0.05, '#0088ff');

  // Obstacle (skip first 3 segments = grace zone)
  let hasObstacle = false;
  if (zOffset > 25 && Math.random() < 0.65) {
    hasObstacle = true;
    spawnObstacle(seg);
  }

  container.appendChild(seg);

  const segData = { entity: seg, z: zOffset, hasObstacle };
  segments.push(segData);
}

function spawnNeonStrip(parent, x, y, color) {
  const strip = document.createElement('a-box');
  strip.setAttribute('position', `${x} ${y} -${SEGMENT_LENGTH/2}`);
  strip.setAttribute('width', 0.04);
  strip.setAttribute('height', 0.04);
  strip.setAttribute('depth', SEGMENT_LENGTH);
  strip.setAttribute('material', `color: ${color}; emissive: ${color}; emissiveIntensity: 1; shader: flat`);
  parent.appendChild(strip);
}

function spawnObstacle(parent) {
  const types = ['wall-gap', 'pillar', 'low-bar', 'high-bar'];
  const type = types[Math.floor(Math.random() * types.length)];

  // Place obstacle within the segment at a random depth (negative Z = into screen)
  const localZ = -(SEGMENT_LENGTH * 0.3 + Math.random() * SEGMENT_LENGTH * 0.5);

  if (type === 'wall-gap') {
    const gapSide = Math.random() < 0.5 ? 'left' : 'right';
    const gapWidth = 2.2;
    if (gapSide === 'left') {
      makeObstacleBox(parent, TRACK_WIDTH/4, TRACK_HEIGHT/2, localZ, TRACK_WIDTH/2 - gapWidth/2, TRACK_HEIGHT, 0.4, '#ff2244', '#ff4466');
    } else {
      makeObstacleBox(parent, -TRACK_WIDTH/4, TRACK_HEIGHT/2, localZ, TRACK_WIDTH/2 - gapWidth/2, TRACK_HEIGHT, 0.4, '#ff2244', '#ff4466');
    }
  } else if (type === 'pillar') {
    const laneX = (Math.floor(Math.random() * 3) - 1) * LANE_WIDTH;
    makeObstacleBox(parent, laneX, TRACK_HEIGHT/2, localZ, 1.0, TRACK_HEIGHT, 1.0, '#ff6600', '#ff8800');
  } else if (type === 'low-bar') {
    makeObstacleBox(parent, 0, 0.5, localZ, TRACK_WIDTH - 0.4, 0.5, 0.4, '#aa00ff', '#cc44ff');
  } else if (type === 'high-bar') {
    makeObstacleBox(parent, 0, TRACK_HEIGHT - 0.5, localZ, TRACK_WIDTH - 0.4, 0.5, 0.4, '#0088ff', '#44aaff');
  }
}

function makeObstacleBox(parent, x, y, z, w, h, d, color, emissive) {
  const box = document.createElement('a-box');
  box.setAttribute('position', `${x} ${y} ${z}`);
  box.setAttribute('width', w);
  box.setAttribute('height', h);
  box.setAttribute('depth', d);
  box.setAttribute('material', `color: ${color}; emissive: ${emissive}; emissiveIntensity: 0.8; transparent: true; opacity: 0.9`);
  box.classList.add('obstacle');
  parent.appendChild(box);
  obstacles.push({
    entity: box,
    parentSeg: parent,
    localZ: z,
    worldX: x,
    halfW: w / 2,
    minY: y - h / 2,
    maxY: y + h / 2,
  });
}

// ============================================================
//  GAME LOOP
// ============================================================
let lastTime = null;

function startGame() {
  document.getElementById('ui-overlay').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  document.getElementById('bob-meter').classList.remove('hidden');
  gameActive = true;
  gameOver = false;
  score = 0;
  distanceTraveled = 0;
  baseSpeed = 10;
  stepBoost = 0;
  totalSteps = 0;
  trackZ = 0;
  playerLaneX = 0;
  lastTime = null;
  // Reset bob detector
  headPeak = null;
  headValley = null;
  headYSmooth = null;
  prevSmooth = null;
  dirConfirm = 0;
  lastDir = 0;
  bobCooldown = 0;
  stepFlash = 0;

  // Reset track
  const container = document.getElementById('track-container');
  while (container.firstChild) container.removeChild(container.firstChild);
  segments = [];
  obstacles = [];
  buildInitialTrack();

  // Reset rig
  const rig = document.getElementById('rig');
  rig.setAttribute('position', '0 0 0');

  requestAnimationFrame(gameLoop);
}

function restartGame() {
  document.getElementById('game-over-screen').classList.remove('visible');
  startGame();
}

function gameLoop(timestamp) {
  if (!gameActive) return;
  if (lastTime === null) lastTime = timestamp;
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  const cam = document.getElementById('head-cam');
  const rigEl = document.getElementById('rig');

  // --- HEAD BOB DETECTION (VR) ---
  const camWorldPos = new THREE.Vector3();
  cam.object3D.getWorldPosition(camWorldPos);
  detectBob(camWorldPos.y, dt);

  // --- KEYBOARD FALLBACK ---
  handleKeyboard(dt);

  // --- LATERAL STEERING ---
  // Keyboard A/D steering
  let kbSteer = 0;
  if (keys['a'] || keys['arrowleft'])  kbSteer = -1;
  if (keys['d'] || keys['arrowright']) kbSteer =  1;

  // Head look-direction steering (works in VR and mouse-look)
  const headDir = new THREE.Vector3();
  cam.object3D.getWorldDirection(headDir);
  const lookSteer = Math.max(-1, Math.min(1, headDir.x * 2.0));

  // Combine: keyboard takes priority if pressed, else use head direction
  const effectiveSteer = (kbSteer !== 0) ? kbSteer : lookSteer;
  playerLaneX += effectiveSteer * 4 * dt;
  playerLaneX = Math.max(-TRACK_WIDTH / 2 + 0.6, Math.min(TRACK_WIDTH / 2 - 0.6, playerLaneX));
  rigEl.setAttribute('position', `${playerLaneX} 0 0`);

  // --- FORWARD MOVEMENT ---
  // Only move when stepBoost is active (earned by bobbing/walking)
  const currentSpeed = stepBoost;
  const forwardDelta = currentSpeed * dt;
  trackZ += forwardDelta;
  distanceTraveled += forwardDelta;

  // Decay step boost ‚Äî decays quickly so you must keep walking
  stepBoost = Math.max(0, stepBoost - dt * 6);

  // Speed ramp: max step boost increases over distance
  baseSpeed = 10 + distanceTraveled * 0.005;
  baseSpeed = Math.min(baseSpeed, 25);

  // Move track: segments are at -Z, we shift container in +Z so they approach the player
  const trackContainer = document.getElementById('track-container');
  trackContainer.setAttribute('position', `0 0 ${trackZ}`);

  // --- OBSTACLE COLLISION ---
  checkCollision(rigEl);

  // --- SEGMENT MANAGEMENT ---
  manageSegments();

  // --- HUD UPDATE ---
  score = Math.floor(distanceTraveled);
  document.getElementById('score-display').textContent = score + 'm';
  document.getElementById('speed-display').textContent = stepBoost > 0 ? (stepBoost / 10).toFixed(1) + 'x' : 'STOP';

  // Bob meter
  const meterPct = Math.min(100, (bobDisplay / bobThreshold) * 100);
  document.getElementById('meter-fill').style.width = meterPct + '%';
  bobDisplay = Math.max(0, bobDisplay - dt * 0.1);

  requestAnimationFrame(gameLoop);
}

// ============================================================
//  HEAD BOB DETECTION ‚Äî peak/valley tracker
// ============================================================

// We track a running peak (local max) and valley (local min).
// When head reverses direction after dropping BOB_MIN_EXCURSION meters,
// we count a step. This is robust to Quest 3's 72/90Hz tracking.

const BOB_MIN_EXCURSION = 0.02; // 2cm vertical travel = one step (tune down if needed)
const BOB_DIRECTION_SMOOTHING = 8; // frames to confirm direction reversal

let headPeak = null;       // highest Y seen in current upswing
let headValley = null;     // lowest Y seen in current downswing
let headYSmooth = null;    // exponentially smoothed head Y
let prevSmooth = null;
let dirConfirm = 0;        // positive = confirming upward, negative = confirming downward
let lastDir = 0;           // 1 = going up, -1 = going down
let stepFlash = 0;         // for visual feedback

function detectBob(rawY, dt) {
  // Exponential smoothing to remove jitter but keep real motion
  if (headYSmooth === null) { headYSmooth = rawY; prevSmooth = rawY; headPeak = rawY; headValley = rawY; return; }
  headYSmooth += (rawY - headYSmooth) * 0.4;

  const dy = headYSmooth - prevSmooth;
  prevSmooth = headYSmooth;

  // Direction confirmation: accumulate direction signal
  dirConfirm += dy > 0 ? 1 : dy < 0 ? -1 : 0;
  dirConfirm = Math.max(-BOB_DIRECTION_SMOOTHING, Math.min(BOB_DIRECTION_SMOOTHING, dirConfirm));

  const newDir = dirConfirm >= 3 ? 1 : dirConfirm <= -3 ? -1 : lastDir;

  if (newDir !== lastDir) {
    // Direction changed
    if (lastDir === 1 && newDir === -1) {
      // Was going up, now going down ‚Üí record peak
      headPeak = headYSmooth;
    }
    if (lastDir === -1 && newDir === 1) {
      // Was going down, now going up ‚Üí record valley, check excursion
      headValley = headYSmooth;
      if (headPeak !== null) {
        const excursion = headPeak - headValley;
        if (excursion >= BOB_MIN_EXCURSION && bobCooldown <= 0) {
          registerStep();
          bobCooldown = 0.25;
          stepFlash = 0.15;
        }
      }
      headPeak = headYSmooth; // reset for next cycle
    }
    lastDir = newDir;
  }

  // Track running peak/valley within current direction
  if (lastDir === 1 && headYSmooth > (headPeak ?? headYSmooth)) headPeak = headYSmooth;
  if (lastDir === -1 && headYSmooth < (headValley ?? headYSmooth)) headValley = headYSmooth;

  if (bobCooldown > 0) bobCooldown -= dt;
  if (stepFlash > 0) stepFlash -= dt;

  // Update excursion display for meter
  bobDisplay = headPeak !== null && headValley !== null ? Math.abs(headPeak - headYSmooth) / BOB_MIN_EXCURSION : 0;

  // Update in-scene debug text
  updateDebugHUD(rawY, dy);
}

function updateDebugHUD(rawY, dy) {
  const el = document.getElementById('debug-y');
  if (el) el.textContent = rawY.toFixed(3);
  const el2 = document.getElementById('debug-bob');
  if (el2) el2.textContent = (headPeak !== null && headValley !== null ? (headPeak - (headValley ?? headYSmooth)).toFixed(3) : '---');
  const el3 = document.getElementById('debug-steps');
  if (el3) el3.textContent = totalSteps;

  // Flash step meter on step
  const fill = document.getElementById('meter-fill');
  if (fill) {
    if (stepFlash > 0) {
      fill.style.background = 'linear-gradient(90deg, #ffffff, #00ffcc)';
    } else {
      fill.style.background = 'linear-gradient(90deg, #00ffcc, #00ff88)';
    }
  }

  // Update in-VR debug text entity if present
  const vrDbg = document.getElementById('vr-debug-text');
  if (vrDbg) {
    const excursion = headPeak !== null && headValley !== null ? (headPeak - headYSmooth).toFixed(3) : '?';
    vrDbg.setAttribute('value',
      `Y: ${rawY.toFixed(3)}\nExcursion: ${excursion}\nThreshold: ${BOB_MIN_EXCURSION}\nSteps: ${totalSteps}\nDir: ${lastDir > 0 ? 'UP' : lastDir < 0 ? 'DOWN' : '---'}`
    );
  }
}

function registerStep() {
  totalSteps++;
  stepBoost = Math.min(stepBoost + baseSpeed, baseSpeed * 1.5);

  // Flash in-VR step indicator
  const flashEl = document.getElementById('vr-step-flash');
  if (flashEl) {
    flashEl.setAttribute('value', '‚úì STEP');
    setTimeout(() => flashEl.setAttribute('value', ''), 200);
  }
}

// ============================================================
//  KEYBOARD FALLBACK
// ============================================================
function handleKeyboard(dt) {
  if (keys['w'] || keys['arrowup']) {
    kbBobTimer += dt;
    if (kbBobTimer > 0.35) {
      kbBobTimer = 0;
      registerStep();
    }
  } else {
    kbBobTimer = 0;
  }
}

// ============================================================
//  COLLISION DETECTION
// ============================================================
function checkCollision(rigEl) {
  // Player world X position
  const px = playerLaneX;
  // Camera height is fixed at 1.6 in the rig
  const playerMinY = 0.8;
  const playerMaxY = 1.9;
  const playerMinX = px - 0.35;
  const playerMaxX = px + 0.35;

  // Player is always at world Z=0. Obstacles move toward Z=0 via trackZ offset.
  // Obstacle world Z = (segBaseZ_in_track_space) + trackZ
  // segBaseZ_in_track_space = -seg.z (segments are placed at negative Z in track container)
  // So obstacle world Z = trackZ - seg.z + obs.localZ

  for (const obs of obstacles) {
    // Find which segment this obstacle belongs to
    const seg = segments.find(s => s.entity === obs.parentSeg);
    if (!seg) continue;

    // Obstacle world Z = trackZ (container offset) + (-seg.z) (segment position) + localZ (obstacle within seg)
    // localZ is already negative so this brings the obstacle closer to Z=0 as trackZ increases
    const obsWorldZ = trackZ - seg.z + obs.localZ;

    // Only check obstacles near the player (within ¬±2 units of Z=0)
    if (obsWorldZ < -2 || obsWorldZ > 2) continue;

    const obsX = obs.worldX;
    const obsHalfW = obs.halfW;
    const obsMinY = obs.minY;
    const obsMaxY = obs.maxY;

    const hitX = playerMaxX > obsX - obsHalfW && playerMinX < obsX + obsHalfW;
    const hitY = playerMaxY > obsMinY && playerMinY < obsMaxY;

    if (hitX && hitY) {
      triggerGameOver();
      return;
    }
  }
}

// ============================================================
//  SEGMENT MANAGEMENT
// ============================================================
function manageSegments() {
  // A segment's world Z = trackZ - seg.z (since segment is at -seg.z in container, container is at +trackZ)
  // When worldZ > SEGMENT_LENGTH, it's fully behind the player ‚Üí cull it
  for (let i = segments.length - 1; i >= 0; i--) {
    const seg = segments[i];
    const worldZ = trackZ - seg.z;
    if (worldZ > SEGMENT_LENGTH) {
      seg.entity.parentNode.removeChild(seg.entity);
      obstacles = obstacles.filter(o => o.parentSeg !== seg.entity);
      segments.splice(i, 1);
    }
  }

  // Spawn new segments ahead (most negative Z)
  const farthestZ = segments.reduce((m, s) => Math.max(m, s.z), 0);
  while (segments.length < SEGMENT_COUNT) {
    spawnSegment(farthestZ + SEGMENT_LENGTH);
  }
}

// ============================================================
//  GAME OVER
// ============================================================
function triggerGameOver() {
  if (gameOver) return;
  gameOver = true;
  gameActive = false;

  document.getElementById('hud').classList.add('hidden');
  document.getElementById('bob-meter').classList.add('hidden');

  document.getElementById('final-score').textContent = 'DISTANCE: ' + score + 'm';
  document.getElementById('ui-overlay').classList.remove('hidden');
  document.getElementById('game-over-screen').classList.add('visible');
  document.getElementById('start-screen').style.display = 'none';
}
</script>

</body>
</html>
