<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HEAD RUN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; font-family: 'Courier New', monospace; overflow: hidden; }
    canvas { display: block; }

    #overlay {
      position: fixed; inset: 0; z-index: 10;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,0.9); color: #00ffcc;
      pointer-events: none;
    }
    #overlay.hidden { display: none; }

    #start-screen { text-align: center; pointer-events: all; }
    h1 {
      font-size: clamp(2.5rem, 7vw, 5rem);
      letter-spacing: 0.35em; color: #00ffcc;
      text-shadow: 0 0 40px #00ffcc, 0 0 80px #00ffcc66;
      margin-bottom: 0.3rem;
    }
    .sub { font-size: 0.85rem; letter-spacing: 0.25em; color: #00ffcc55; margin-bottom: 2.5rem; }

    .card {
      background: rgba(0,255,204,0.04);
      border: 1px solid rgba(0,255,204,0.2);
      border-radius: 10px; padding: 1rem 1.4rem;
      margin-bottom: 0.7rem; max-width: 370px;
      text-align: left; font-size: 0.8rem;
      line-height: 1.75; color: #99eedd;
    }
    .card strong {
      color: #00ffcc; display: block; margin-bottom: 0.25rem;
      font-size: 0.65rem; letter-spacing: 0.18em; text-transform: uppercase;
    }

    .btn {
      display: inline-block; margin-top: 1.4rem;
      padding: 0.85rem 2.8rem;
      background: transparent; border: 2px solid #00ffcc;
      color: #00ffcc; font-family: 'Courier New', monospace;
      font-size: 0.95rem; letter-spacing: 0.3em; text-transform: uppercase;
      cursor: pointer; transition: all 0.18s;
      box-shadow: 0 0 24px rgba(0,255,204,0.12);
    }
    .btn:hover { background: rgba(0,255,204,0.08); box-shadow: 0 0 40px rgba(0,255,204,0.3); }

    #game-over { text-align: center; pointer-events: all; display: none; }
    #game-over.show { display: block; }
    #game-over h2 { font-size: clamp(2rem,5vw,3.5rem); letter-spacing: 0.3em; color: #ff3355; text-shadow: 0 0 30px #ff3355; margin-bottom: 0.8rem; }
    #final-dist { font-size: 1.1rem; color: #00ffcc; letter-spacing: 0.15em; margin-bottom: 1.5rem; }

    #hud {
      position: fixed; top: 0; left: 0; right: 0; z-index: 9;
      padding: 1rem 1.4rem; display: flex;
      justify-content: space-between; pointer-events: none;
    }
    #hud.hidden { display: none; }
    .hpanel {
      background: rgba(0,0,0,0.65);
      border: 1px solid rgba(0,255,204,0.25);
      border-radius: 6px; padding: 0.35rem 0.85rem; color: #00ffcc;
    }
    .hlabel { font-size: 0.52rem; letter-spacing: 0.2em; text-transform: uppercase; color: #00ffcc44; }
    .hval { font-size: 1.25rem; text-shadow: 0 0 8px #00ffcc; }

    #stepmeter {
      position: fixed; bottom: 1.8rem; left: 50%;
      transform: translateX(-50%); width: 170px; z-index: 9; pointer-events: none;
    }
    #stepmeter.hidden { display: none; }
    .mlabel { text-align: center; font-size: 0.52rem; letter-spacing: 0.15em; text-transform: uppercase; color: #00ffcc44; margin-bottom: 3px; }
    .mtrack { background: rgba(0,255,204,0.08); border: 1px solid rgba(0,255,204,0.25); border-radius: 20px; height: 7px; overflow: hidden; }
    #mfill { height: 100%; width: 0; border-radius: 20px; background: linear-gradient(90deg,#00ffcc,#00ff88); box-shadow: 0 0 8px #00ffcc; transition: width 0.07s; }

    #vr-btn {
      position: fixed; bottom: 1.5rem; right: 1.5rem; z-index: 20;
      padding: 0.7rem 1.6rem;
      background: rgba(0,0,0,0.8); border: 2px solid #00ffcc;
      color: #00ffcc; font-family: 'Courier New', monospace;
      font-size: 0.8rem; letter-spacing: 0.2em; text-transform: uppercase;
      cursor: pointer; border-radius: 6px;
      box-shadow: 0 0 20px rgba(0,255,204,0.2);
    }
    #vr-btn.hidden { display: none; }
  </style>
</head>
<body>

<!-- UI -->
<div id="overlay">
  <div id="start-screen">
    <h1>HEAD RUN</h1>
    <p class="sub">‚àû infinite vr runner ‚àû</p>
    <div class="card">
      <strong>üéÆ VR Movement</strong>
      Bob your head up and down to move ‚Äî each full bob cycle propels you forward.
      Stop bobbing and you stop.
    </div>
    <div class="card">
      <strong>üñ•Ô∏è Desktop</strong>
      Tap <kbd>W</kbd> rhythmically. Mouse or <kbd>A</kbd>/<kbd>D</kbd> to steer.
    </div>
    <div class="card">
      <strong>‚ö†Ô∏è Obstacles</strong>
      Look left or right to steer around walls and pillars. Speed increases over time.
    </div>
    <button class="btn" id="start-btn">ENTER THE RUN</button>
  </div>
  <div id="game-over">
    <h2>COLLISION</h2>
    <div id="final-dist">0m</div>
    <button class="btn" id="restart-btn">RUN AGAIN</button>
  </div>
</div>

<div id="hud" class="hidden">
  <div class="hpanel"><div class="hlabel">Distance</div><div class="hval" id="hdist">0m</div></div>
  <div class="hpanel"><div class="hlabel">Speed</div><div class="hval" id="hspeed">STOP</div></div>
</div>

<div id="stepmeter" class="hidden">
  <div class="mlabel">Bob Power</div>
  <div class="mtrack"><div id="mfill"></div></div>
</div>

<button id="vr-btn" class="hidden">ENTER VR</button>

<script type="importmap">
{
  "imports": {
    "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';

// ‚îÄ‚îÄ‚îÄ THREE / RENDERER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
renderer.shadowMap.enabled = false;
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
});

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050510);
scene.fog = new THREE.FogExp2(0x050510, 0.038);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
camera.position.set(0, 1.6, 0);

// Player rig ‚Äî we move this in X for steering
const rig = new THREE.Group();
rig.add(camera);
scene.add(rig);

// Lighting
scene.add(new THREE.AmbientLight(0x001122, 0.6));
const dirLight = new THREE.DirectionalLight(0x00ffcc, 0.4);
dirLight.position.set(0, 5, -5);
scene.add(dirLight);

// ‚îÄ‚îÄ‚îÄ VR SETUP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let xrSession = null;
let xrRefSpace = null;
let inVR = false;

const vrBtn = document.getElementById('vr-btn');

async function checkVRSupport() {
  if (navigator.xr) {
    const supported = await navigator.xr.isSessionSupported('immersive-vr');
    if (supported) vrBtn.classList.remove('hidden');
  }
}
checkVRSupport();

vrBtn.addEventListener('click', async () => {
  if (xrSession) return;
  try {
    xrSession = await navigator.xr.requestSession('immersive-vr', {
      requiredFeatures: ['local-floor'],
      optionalFeatures: ['bounded-floor', 'hand-tracking']
    });
    await renderer.xr.setSession(xrSession);
    // Get floor-relative reference space for accurate Y tracking
    xrRefSpace = await xrSession.requestReferenceSpace('local-floor');
    renderer.xr.setReferenceSpace(xrRefSpace);
    inVR = true;
    vrBtn.classList.add('hidden');
    xrSession.addEventListener('end', () => {
      xrSession = null; xrRefSpace = null; inVR = false;
      vrBtn.classList.remove('hidden');
    });
  } catch(e) {
    console.error('XR session failed:', e);
  }
});

// ‚îÄ‚îÄ‚îÄ CONSTANTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SEG_LEN   = 12;
const SEG_COUNT = 16;
const TW        = 6;
const TH        = 3.5;
const LANE_W    = 1.6;

const BOB_EXCURSION  = 0.006; // metres peak‚Üívalley to register step (~6mm)
const BOB_ALPHA      = 0.25;  // EMA smoothing (lower = more smoothing)
const DIR_CONFIRM    = 5;     // frames to confirm direction change
const BOB_COOLDOWN   = 0.20;  // seconds between steps
const BOOST_AMOUNT   = 6;     // speed units added per step
const BOOST_DECAY    = 2.5;   // speed units lost per second

// ‚îÄ‚îÄ‚îÄ MATERIALS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const matFloor   = new THREE.MeshLambertMaterial({ color: 0x001133, emissive: 0x000511 });
const matWall    = new THREE.MeshLambertMaterial({ color: 0x000a22, emissive: 0x001133, side: THREE.FrontSide });
const matCeil    = new THREE.MeshLambertMaterial({ color: 0x000822, emissive: 0x000a1a });
const matNeonG   = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
const matNeonB   = new THREE.MeshBasicMaterial({ color: 0x0055ff });
const matObs = [
  new THREE.MeshBasicMaterial({ color: 0xff2244, transparent: true, opacity: 0.9 }),
  new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.9 }),
  new THREE.MeshBasicMaterial({ color: 0xaa00ff, transparent: true, opacity: 0.9 }),
  new THREE.MeshBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0.9 }),
];

// ‚îÄ‚îÄ‚îÄ TRACK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const trackContainer = new THREE.Group();
scene.add(trackContainer);

let segments  = []; // { group, z }
let obstacles = []; // { z (world), x, hw, y, hh }  ‚Äî precomputed in local-track coords

function spawnSegment(z) {
  const g = new THREE.Group();
  g.position.z = -z;

  const hw = TW / 2, hh = TH / 2;
  const sl = SEG_LEN;

  // Floor
  addBox(g, TW, 0.05, sl, 0, -0.025, -sl/2, matFloor);
  // Left wall
  addBox(g, 0.05, TH, sl, -hw, hh, -sl/2, matWall);
  // Right wall
  addBox(g, 0.05, TH, sl,  hw, hh, -sl/2, matWall);
  // Ceiling
  addBox(g, TW, 0.05, sl, 0, TH+0.025, -sl/2, matCeil);

  // Neon strips along the tunnel
  addBox(g, 0.06, 0.06, sl, -hw+0.03, 0.03,    -sl/2, matNeonG);
  addBox(g, 0.06, 0.06, sl,  hw-0.03, 0.03,    -sl/2, matNeonG);
  addBox(g, 0.06, 0.06, sl, -hw+0.03, TH-0.03, -sl/2, matNeonB);
  addBox(g, 0.06, 0.06, sl,  hw-0.03, TH-0.03, -sl/2, matNeonB);

  // Obstacles (skip first grace zone)
  if (z > 35 && Math.random() < 0.72) spawnObstacle(g, z);

  trackContainer.add(g);
  segments.push({ group: g, z });
}

function addBox(parent, w, h, d, x, y, z, mat) {
  const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
  m.position.set(x, y, z);
  parent.add(m);
  return m;
}

function spawnObstacle(parent, segZ) {
  const type = Math.floor(Math.random() * 2); // 0=side wall, 1=pillar only
  const lz = -(SEG_LEN * 0.2 + Math.random() * SEG_LEN * 0.55);
  const mat = matObs[type];

  if (type === 0) {
    // Side wall with gap
    const onRight = Math.random() < 0.5;
    const bx = onRight ? TW/4 : -TW/4;
    const w = TW/2 - 0.85;
    addBox(parent, w, TH, 0.55, bx, TH/2, lz, mat);
    obstacles.push({ segZ, lz, x: bx, hw: w/2, y: TH/2, hh: TH/2 });
  } else if (type === 1) {
    // Pillar in a lane
    const lx = (Math.floor(Math.random()*3)-1) * LANE_W;
    addBox(parent, 1.1, TH, 1.1, lx, TH/2, lz, mat);
    obstacles.push({ segZ, lz, x: lx, hw: 0.55, y: TH/2, hh: TH/2 });
  } else if (type === 2) {
    // Low bar
    addBox(parent, TW-0.5, 0.55, 0.55, 0, 0.45, lz, mat);
    obstacles.push({ segZ, lz, x: 0, hw: (TW-0.5)/2, y: 0.45, hh: 0.275 });
  } else {
    // High bar
    addBox(parent, TW-0.5, 0.55, 0.55, 0, TH-0.4, lz, mat);
    obstacles.push({ segZ, lz, x: 0, hw: (TW-0.5)/2, y: TH-0.4, hh: 0.275 });
  }
}

function buildTrack() {
  for (let i = 0; i < SEG_COUNT; i++) spawnSegment(i * SEG_LEN);
}

// ‚îÄ‚îÄ‚îÄ IN-VR DEBUG SPRITE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// A canvas texture attached to the camera so it's always in view
const dbgCanvas  = document.createElement('canvas');
dbgCanvas.width  = 512; dbgCanvas.height = 256;
const dbgCtx     = dbgCanvas.getContext('2d');
const dbgTex     = new THREE.CanvasTexture(dbgCanvas);
const dbgMat     = new THREE.MeshBasicMaterial({ map: dbgTex, transparent: true, depthTest: false });
const dbgPlane   = new THREE.Mesh(new THREE.PlaneGeometry(0.45, 0.22), dbgMat);
dbgPlane.position.set(0, 0, -0.65);
dbgPlane.renderOrder = 999;
camera.add(dbgPlane);

function updateDebugCanvas(lines, stepFlash) {
  const c = dbgCtx;
  c.clearRect(0, 0, 512, 256);
  c.fillStyle = 'rgba(0,0,16,0.78)';
  roundRect(c, 0, 0, 512, 256, 18);
  c.fill();
  c.font = 'bold 32px monospace';
  c.fillStyle = stepFlash ? '#ffffff' : '#00ffcc';
  lines.forEach((l, i) => c.fillText(l, 20, 44 + i * 42));
  if (stepFlash) {
    c.fillStyle = '#ffffff';
    c.font = 'bold 38px monospace';
    c.fillText('‚úì STEP!', 280, 220);
  }
  dbgTex.needsUpdate = true;
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y); ctx.arcTo(x+w, y, x+w, y+r, r);
  ctx.lineTo(x+w, y+h-r); ctx.arcTo(x+w, y+h, x+w-r, y+h, r);
  ctx.lineTo(x+r, y+h); ctx.arcTo(x, y+h, x, y+h-r, r);
  ctx.lineTo(x, y+r); ctx.arcTo(x, y, x+r, y, r);
  ctx.closePath();
}

// ‚îÄ‚îÄ‚îÄ GAME STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let gameActive = false;
let gameOver   = false;
let trackZ     = 0;
let playerX    = 0;
let distance   = 0;
let stepBoost  = 0;
let speedCap   = 14;

// Bob detection
let smoothY    = null;
let prevSmooth = null;
let peakY      = null;
let valleyY    = null;
let bobDir     = 0;
let dirCount   = 0;
let bobCooldown = 0;
let totalSteps  = 0;
let stepFlash   = 0;

// Keyboard
let keys   = {};
let kbTimer = 0;

window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup',   e => keys[e.key.toLowerCase()] = false);

// Mouse look (desktop)
let yaw = 0;
let isPointerLocked = false;
renderer.domElement.addEventListener('click', () => {
  if (!inVR && gameActive) renderer.domElement.requestPointerLock();
});
document.addEventListener('pointerlockchange', () => {
  isPointerLocked = document.pointerLockElement === renderer.domElement;
});
document.addEventListener('mousemove', e => {
  if (isPointerLocked && !inVR) {
    yaw -= e.movementX * 0.002;
    camera.rotation.y = yaw;
  }
});

// ‚îÄ‚îÄ‚îÄ GAME CONTROL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startGame() {
  document.getElementById('overlay').classList.add('hidden');
  document.getElementById('hud').classList.remove('hidden');
  document.getElementById('stepmeter').classList.remove('hidden');
  document.getElementById('start-screen').style.display = 'block';

  gameActive = true; gameOver = false;
  trackZ = 0; playerX = 0; distance = 0;
  stepBoost = 0; speedCap = 6;
  totalSteps = 0; kbTimer = 0;
  smoothY = null; prevSmooth = null;
  peakY = null; valleyY = null;
  bobDir = 0; dirCount = 0; bobCooldown = 0; stepFlash = 0;
  yaw = 0; camera.rotation.set(0, 0, 0);

  // Clear track
  while (trackContainer.children.length) trackContainer.remove(trackContainer.children[0]);
  segments = []; obstacles = [];
  rig.position.set(0, 0, 0);
  buildTrack();
}

function endGame() {
  if (gameOver) return;
  gameOver = true; gameActive = false;
  document.getElementById('hud').classList.add('hidden');
  document.getElementById('stepmeter').classList.add('hidden');
  document.getElementById('final-dist').textContent = 'DISTANCE: ' + Math.floor(distance) + 'm';
  document.getElementById('overlay').classList.remove('hidden');
  document.getElementById('game-over').classList.add('show');
  document.getElementById('start-screen').style.display = 'none';
}

function restartGame() {
  document.getElementById('game-over').classList.remove('show');
  startGame();
}

document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', restartGame);

// ‚îÄ‚îÄ‚îÄ BOB DETECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function detectBob(rawY, dt) {
  if (smoothY === null) {
    smoothY = rawY; prevSmooth = rawY;
    peakY = rawY; valleyY = rawY; bobDir = 0; dirCount = 0;
    return;
  }

  smoothY += (rawY - smoothY) * BOB_ALPHA;
  const dy = smoothY - prevSmooth;
  prevSmooth = smoothY;

  // Accumulate direction confirmation
  if      (dy >  0.00005) dirCount = Math.min(dirCount + 1,  DIR_CONFIRM + 6);
  else if (dy < -0.00005) dirCount = Math.max(dirCount - 1, -(DIR_CONFIRM + 6));

  const newDir =
    dirCount >=  DIR_CONFIRM ?  1 :
    dirCount <= -DIR_CONFIRM ? -1 : bobDir;

  if (newDir !== bobDir && newDir !== 0) {
    if (newDir === -1) {
      // Turned downward ‚Äî record peak
      peakY = smoothY;
    }
    if (newDir === 1 && bobDir === -1) {
      // Turned upward after going down ‚Äî check excursion
      valleyY = smoothY;
      const excursion = (peakY ?? smoothY) - valleyY;
      if (excursion >= BOB_EXCURSION && bobCooldown <= 0) {
        registerStep(excursion);
      }
      peakY = smoothY;
    }
    bobDir = newDir;
  }

  // Track running peak/valley
  if (bobDir ===  1 && smoothY > (peakY   ?? -Infinity)) peakY   = smoothY;
  if (bobDir === -1 && smoothY < (valleyY ??  Infinity)) valleyY = smoothY;
}

function registerStep(excursion) {
  totalSteps++;
  bobCooldown = BOB_COOLDOWN;
  const boost = Math.min(BOOST_AMOUNT * (1 + excursion * 4), BOOST_AMOUNT * 1.5);
  stepBoost = Math.min(stepBoost + boost, speedCap);
  stepFlash = 0.3;
}

// ‚îÄ‚îÄ‚îÄ COLLISION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function checkCollision() {
  const px = playerX;
  const pMinX = px - 0.38, pMaxX = px + 0.38;
  const pMinY = 0.65,      pMaxY = 2.0;

  for (const obs of obstacles) {
    // Container is at +trackZ. Segment is at -obs.segZ within container.
    // Obstacle is at obs.lz within segment. Player sits at world Z=0.
    // Obstacle world Z = trackZ - obs.segZ + obs.lz
    // Passes player when this ‚âà 0, i.e. trackZ ‚âà segZ - lz
    const wz = trackZ - obs.segZ + obs.lz;
    if (wz < -1.8 || wz > 1.0) continue;

    if (pMaxX > obs.x - obs.hw && pMinX < obs.x + obs.hw &&
        pMaxY > obs.y - obs.hh && pMinY < obs.y + obs.hh) {
      endGame();
      return;
    }
  }
}

// ‚îÄ‚îÄ‚îÄ MAIN RENDER LOOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let lastTime = null;

renderer.setAnimationLoop((time, frame) => {
  const now = time / 1000;
  const dt = lastTime !== null ? Math.min(now - lastTime, 0.05) : 0;
  lastTime = now;

  if (!gameActive) {
    renderer.render(scene, camera);
    return;
  }

  // ‚îÄ‚îÄ HEAD Y from XR frame (VR) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  let headY = camera.getWorldPosition(new THREE.Vector3()).y;

  if (inVR && frame && xrRefSpace) {
    try {
      const pose = frame.getViewerPose(xrRefSpace);
      if (pose) {
        // This is the real physical head Y in metres above the floor
        headY = pose.transform.position.y;
      }
    } catch(e) {}
  }

  detectBob(headY, dt);
  if (bobCooldown > 0) bobCooldown -= dt;
  if (stepFlash   > 0) stepFlash   -= dt;

  // ‚îÄ‚îÄ Keyboard steps ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (keys['w'] || keys['arrowup']) {
    kbTimer += dt;
    if (kbTimer >= 0.32) { kbTimer = 0; registerStep(BOB_EXCURSION * 2); }
  } else kbTimer = 0;

  // ‚îÄ‚îÄ Steering ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  let steer = 0;
  if (keys['a'] || keys['arrowleft'])  steer = -1;
  if (keys['d'] || keys['arrowright']) steer =  1;

  if (steer === 0) {
    // Use camera look direction for steering (works in VR naturally)
    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    steer = Math.max(-1, Math.min(1, dir.x * 2.5));
  }

  playerX = Math.max(-TW/2 + 0.55, Math.min(TW/2 - 0.55, playerX + steer * 4 * dt));
  rig.position.x = playerX;

  // ‚îÄ‚îÄ Forward movement ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  trackZ   += stepBoost * dt;
  distance += stepBoost * dt;
  stepBoost = Math.max(0, stepBoost - BOOST_DECAY * dt);
  speedCap  = Math.min(14, 6 + distance * 0.003);
  // Segments are at -segZ inside container. Moving container by +trackZ
  // brings them toward world Z=0 (where the player stands).
  trackContainer.position.z = trackZ;

  // ‚îÄ‚îÄ Segment recycling ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const farthest = segments.reduce((m, s) => Math.max(m, s.z), 0);
  while (segments.length < SEG_COUNT) spawnSegment(farthest + SEG_LEN);

  for (let i = segments.length - 1; i >= 0; i--) {
    const passed = trackZ - segments[i].z;
    if (passed > SEG_LEN * 2) {
      trackContainer.remove(segments[i].group);
      // Dispose geometries
      segments[i].group.traverse(o => { if (o.geometry) o.geometry.dispose(); });
      obstacles = obstacles.filter(o => o.segZ !== segments[i].z);
      segments.splice(i, 1);
    }
  }

  // ‚îÄ‚îÄ Collision ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  checkCollision();

  // ‚îÄ‚îÄ HUD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  document.getElementById('hdist').textContent  = Math.floor(distance) + 'm';
  document.getElementById('hspeed').textContent =
    stepBoost > 0.5 ? Math.round(stepBoost / BOOST_AMOUNT * 100) + '%' : 'STOP';
  document.getElementById('mfill').style.width  =
    Math.min(100, stepBoost / speedCap * 100) + '%';

  // ‚îÄ‚îÄ VR debug canvas ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const curExc = (peakY !== null && valleyY !== null)
    ? Math.abs(peakY - (valleyY ?? peakY)).toFixed(3) : '-.---';
  updateDebugCanvas([
    `Y: ${headY.toFixed(3)}m`,
    `Exc: ${curExc} / ${BOB_EXCURSION}`,
    `Dir: ${bobDir > 0 ? '‚Üë UP' : bobDir < 0 ? '‚Üì DN' : '-- --'}`,
    `Steps: ${totalSteps}   Cool: ${bobCooldown > 0 ? bobCooldown.toFixed(2)+'s' : 'OK'}`,
    `Boost: ${stepBoost.toFixed(1)}`,
  ], stepFlash > 0);

  renderer.render(scene, camera);
});

// Initial debug canvas
updateDebugCanvas(['Press START to begin', '', '', '', ''], false);

</script>
</body>
</html>
